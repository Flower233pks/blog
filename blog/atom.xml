<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Orchidany&#39;w blog</title>
  
  <subtitle>Love is a touch but yet not a touch</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://Flower233pks.github.io/blog/"/>
  <updated>2019-07-21T02:34:12.694Z</updated>
  <id>https://Flower233pks.github.io/blog/</id>
  
  <author>
    <name>Orchidany</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>随想·目次表</title>
    <link href="https://Flower233pks.github.io/blog/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/"/>
    <id>https://Flower233pks.github.io/blog/2050/12/31/随想·目次表/</id>
    <published>2050-12-31T14:24:26.000Z</published>
    <updated>2019-07-21T02:34:12.694Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>终于又开始了。</p><p>换了新的博客，把之前博客园里的三篇搬了下来。</p><p>每次只要我写，一定是有什么奇妙/特殊/悲伤的事情发生，或者是我内心颇不宁静。当然，往往是后者起决定性因素。</p><p>时隔几个月，我读到第一篇随想时，虽然能感受出暮夏时的无奈与懵懂，但是还是十分幸福的。</p><p>读第二篇丘吉尔时，我内心在撕裂、在纠结，昔日困顿麻木却又敏感的我，再一次呈现在自己眼前，仿佛自己经历了这么多，还是原来那个不变的少年。</p><p>读我$NOIP$的启示录的时候，我能感受到我是多么绝望——我不愿意提及这件事。但无论如何，我从那里面读出了最让人动容的东西——绝处逢生的微芒希望与铺天盖地的绝望，懵懂的爱与切骨的恨，缠绵悠长，时至今日仍然震扣我的灵魂。</p><p>是的，我是花，一个不理智的$Oier$。我也想每天24小时拼出48小时的效率一心做题，但是我做不到，我血液中凝结着的，在催促我写下来，必须要写下来。</p><p>在这些文章里，你会看到一个迷茫的青年如何满怀热血与绝望，眼里闪烁着沧桑与希望，怀里揣着坏掉的粮食和崭新的论文，脚下踏着崎岖不平的路，向明天走去。</p><p>是的，我是花，来自山东，你直接叫我花这个ID或许我会很高兴，但是如果你认识我也可以不这么拘束。</p>        <div id="aplayer-therlima" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-therlima"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "花",              author: "Hello Nico",              url: "Hello Nico-花.flac",              pic: "/blog/2050/12/31/随想·目次表/qwq.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><p>以下是目录：</p><table><thead><tr><th style="text-align:center">题目</th><th style="text-align:center">链接（点击即可）</th></tr></thead><tbody><tr><td style="text-align:center">随想一 · 杨柳岸晓风残月</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/02/%E9%9A%8F%E6%83%B3%E4%B8%80/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想二 · 丘吉尔</td><td style="text-align:center"><a href="http://www.orchidany.cf/2018/08/08/%E9%9A%8F%E6%83%B3%E4%BA%8C/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想三 · 本赛季最后的随想/启示录</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%B8%89%C2%B7NOIP/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想四 · 故人今安否？</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想五 · 手中没有红玫瑰</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/02/14/%E9%9A%8F%E6%83%B3%E4%BA%94%C2%B7%E6%83%85%E4%BA%BA%E8%8A%82/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想六 · 难</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/10/%E9%9A%8F%E6%83%B3%E5%85%AD%C2%B7Hard/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想七 · 言叶之庭</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/" target="_blank" rel="noopener">$Link$</a></td></tr><tr><td style="text-align:center">随想八 · 杏花疏影</td><td style="text-align:center">咕</td></tr><tr><td style="text-align:center">随想九 · 意义</td><td style="text-align:center"><a href="http://www.orchidany.cf/2019/07/18/Nine/" target="_blank" rel="noopener">$Link$</a>                   </td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
    
      <category term="随想/下下笔" scheme="https://Flower233pks.github.io/blog/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>biaodashishu2</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/26/biaodashishu2/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/26/biaodashishu2/</id>
    <published>2019-07-26T01:46:44.000Z</published>
    <updated>2019-07-26T01:46:44.272Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>表达式树入门</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/26/biaodashishu/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/26/biaodashishu/</id>
    <published>2019-07-26T01:46:38.000Z</published>
    <updated>2019-07-26T03:05:02.766Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>严格来讲，我们所谈的<strong>表达式树</strong>是对一个计算式的中缀表达式所构造的<strong>二叉树形结构</strong>，在求解表达式的值时十分的方便。</p><p>对于一棵表达式树，其中每一个节点都表示一个字符，特别的是<strong>数值只会是叶子节点</strong>，这些数值由其祖先节点——均是“计算符号”的节点连接起来。而计算方式则是：<br>$$<br>\rm{S_u=calc(S_{v_1}, S_{v_2})}<br>$$<br>其中u为当前节点，calc函数的计算方式取决于点$u$上的符号。</p><p>从而只需要递归计算即可。</p><a id="more"></a><h1 id="1-递归建树"><a href="#1-递归建树" class="headerlink" title="$1$ 递归建树"></a>$1$ 递归建树</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">isop</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x == <span class="string">'+'</span> || x == <span class="string">'-'</span> || x == <span class="string">'*'</span> || x == <span class="string">'/'</span> || x == <span class="string">'^'</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (brac[l] == r) <span class="keyword">return</span> build(l + <span class="number">1</span>, r - <span class="number">1</span>) ; </span><br><span class="line">rr <span class="keyword">int</span> rt = <span class="number">0</span>, ls = <span class="number">0</span>, rs = <span class="number">0</span>, x = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> k = l ; k &lt;= r ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (In[k] == <span class="string">'('</span>) k = brac[k] + <span class="number">1</span> ; <span class="keyword">if</span> (k &gt; r) <span class="keyword">break</span> ; </span><br><span class="line"><span class="keyword">if</span> ((In[k] == <span class="string">'+'</span> || In[k] == <span class="string">'-'</span>) &amp;&amp; k != l &amp;&amp; !isop(In[k - <span class="number">1</span>])) &#123; rt = k ; <span class="keyword">break</span> ; &#125;<span class="comment">//!</span></span><br><span class="line"><span class="keyword">if</span> (In[k] == <span class="string">'*'</span> || In[k] == <span class="string">'/'</span>) ls = k ; <span class="keyword">if</span> (In[k] == <span class="string">'^'</span> &amp;&amp; !rs) rs = k ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (rt) x = rt ; <span class="keyword">else</span> <span class="keyword">if</span> (ls) x = ls ; <span class="keyword">else</span> x = rs ; </span><br><span class="line"><span class="keyword">if</span> (!x) &#123; </span><br><span class="line">x = r, op[x] = <span class="string">'?'</span> ; </span><br><span class="line"><span class="built_in">sscanf</span>(In + l, <span class="string">"%d"</span>, &amp;val[x]) ; </span><br><span class="line">val[x] %= Mod ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line">op[x] = In[x] ; L[x] = build(l, x - <span class="number">1</span>), R[x] = build(x + <span class="number">1</span>, r) ; <span class="keyword">return</span> x ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">rr <span class="keyword">int</span> res = <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">while</span> (b)&#123;</span><br><span class="line"><span class="keyword">if</span> (b &amp; <span class="number">1</span>) (res *= a) %= Mod ;</span><br><span class="line">(a *= a) %= Mod ; b &gt;&gt;= <span class="number">1</span> ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (op[x] == <span class="string">'?'</span>) <span class="keyword">return</span> val[x] ; </span><br><span class="line">rr <span class="keyword">int</span> l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = <span class="number">0.0</span> ;</span><br><span class="line"><span class="keyword">if</span> (op[x] == <span class="string">'+'</span>) res = (l + r) % Mod ;</span><br><span class="line"><span class="keyword">if</span> (op[x] == <span class="string">'-'</span>) res = (l - r) % Mod ;</span><br><span class="line"><span class="keyword">if</span> (op[x] == <span class="string">'*'</span>) res = (l * r) % Mod ;</span><br><span class="line"><span class="keyword">if</span> (op[x] == <span class="string">'/'</span>) res = l * expow(r, Mod - <span class="number">2</span>) % Mod ;</span><br><span class="line"><span class="keyword">if</span> (op[x] == <span class="string">'^'</span>) res = expow(l ,r) ; <span class="keyword">return</span> res ;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; In + <span class="number">1</span>, N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (In[i] == <span class="string">'('</span>) stk[++ tp] = i ; </span><br><span class="line"><span class="keyword">if</span> (In[i] == <span class="string">')'</span>) brac[i] = stk[tp], brac[stk[tp]] = i, tp -- ;</span><br><span class="line">&#125;</span><br><span class="line">root = build(<span class="number">1</span>, N), <span class="built_in">cout</span> &lt;&lt; dp(root) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实也没啥好说的，这道题是NOIP2013普及组的<a href="https://www.luogu.org/problem/P1981" target="_blank" rel="noopener">表达式求值</a>。然后建树的时候需要注意优先级……</p><p>但其实这个地方想说的不是这个东西，而是一个复杂度的问题。喜闻乐见的这个玩意儿的复杂度是$O(n^2)$的，但是在我加了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((In[k] == <span class="string">'+'</span> || In[k] == <span class="string">'-'</span>) &amp;&amp; k != l &amp;&amp; !isop(In[k - <span class="number">1</span>])) &#123; </span><br><span class="line">  rt = k ; <span class="keyword">break</span> ; </span><br><span class="line">&#125;<span class="comment">//!</span></span><br></pre></td></tr></table></figure><p>中的break之后，他就可以在400ms内的龟速把1e6的数据给艹过去了……也算是很迷</p><p>但听说似乎真正$O(|S|)$的建树其实只需要预处理一下每个位置之前最近的符号就好……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (Code[r][<span class="number">1</span>] &gt;= l) rt = Code[r][<span class="number">1</span>] ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Code[r][<span class="number">2</span>] &gt;= l) rt = Code[r][<span class="number">2</span>] ;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        op[rt] = In[rt], </span><br><span class="line">      L[rt] = build(l, rt - <span class="number">1</span>), </span><br><span class="line">      R[rt] = build(rt + <span class="number">1</span>, r) ; <span class="keyword">return</span> rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    op[r] = <span class="string">'?'</span>, <span class="built_in">sscanf</span>(In + l, <span class="string">"%d"</span>, &amp;val[r]) ; val[r] %= Mod ; <span class="keyword">return</span> r ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'?'</span>) <span class="keyword">return</span> val[x] ;</span><br><span class="line">    <span class="keyword">int</span> l = dp(L[x]) % Mod, r = dp(R[x]) % Mod, res = <span class="number">0.0</span> ;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'+'</span>) res = (l + r) % Mod ;</span><br><span class="line">    <span class="keyword">if</span> (op[x] == <span class="string">'*'</span>) res = (l * r) % Mod ;</span><br><span class="line">    <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">    N = <span class="built_in">strlen</span>(In + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (In[i] == <span class="string">'+'</span>) Add = i ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="string">'*'</span>) Mul = i ;</span><br><span class="line">        Code[i][<span class="number">1</span>] = Add, Code[i][<span class="number">2</span>] = Mul ;</span><br><span class="line">    &#125;</span><br><span class="line">    root = build(<span class="number">1</span>, N) ; <span class="built_in">cout</span> &lt;&lt; dp(root) &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这似乎就是线性的了。然而测了一下速发现：</p><p><img src="1.jpg" alt="$n^2$写法"> </p><p><img src="2.jpg" alt="$|S|$写法"></p><p>似乎并没有什么区别……于是这就很佛了。。</p><h1 id="2-用栈建树"><a href="#2-用栈建树" class="headerlink" title="$2$ 用栈建树"></a>$2$ 用栈建树</h1><p>这其实是在UOJ群里面<code>iki9</code>推荐的方式，我看到似乎兔队也是这么建的，于是就打算学一学。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;严格来讲，我们所谈的&lt;strong&gt;表达式树&lt;/strong&gt;是对一个计算式的中缀表达式所构造的&lt;strong&gt;二叉树形结构&lt;/strong&gt;，在求解表达式的值时十分的方便。&lt;/p&gt;
&lt;p&gt;对于一棵表达式树，其中每一个节点都表示一个字符，特别的是&lt;strong&gt;数值只会是叶子节点&lt;/strong&gt;，这些数值由其祖先节点——均是“计算符号”的节点连接起来。而计算方式则是：&lt;br&gt;$$&lt;br&gt;\rm{S_u=calc(S_{v_1}, S_{v_2})}&lt;br&gt;$$&lt;br&gt;其中u为当前节点，calc函数的计算方式取决于点$u$上的符号。&lt;/p&gt;
&lt;p&gt;从而只需要递归计算即可。&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://Flower233pks.github.io/blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="表达式树" scheme="https://Flower233pks.github.io/blog/tags/%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%A0%91/"/>
    
      <category term="树模型" scheme="https://Flower233pks.github.io/blog/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>0-1BFS</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/24/01BFS/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/24/01BFS/</id>
    <published>2019-07-24T14:06:33.000Z</published>
    <updated>2019-07-24T14:30:11.320Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$\text{0-1BFS}$本质上是一种特殊的图，它的边权有$1$和$0$两种。同时为了保持$BFS$状态单调的特性，使用<strong>0权头入、1权尾入</strong>的入队方式。</p><a id="more"></a><h1 id="1-SP22393-KATHTHI-KATHTHI"><a href="#1-SP22393-KATHTHI-KATHTHI" class="headerlink" title="$1$ SP22393 KATHTHI - KATHTHI"></a>$1$ SP22393 KATHTHI - KATHTHI</h1><blockquote><p>给出一个$n \times m$的网格，每个位置有一个小写字母，初始在$(1, 1)$，每次可以向上下左右走，问走到$(n, m)$的最小花费<br>设$(x, y)$为当前位置，$(nx, ny)$为下一位置。$s[x][y]$表示$(x, y)$位置的字符。<br>若$s[x][y] = s[nx][ny]$，则移动的花费为0，否则花费为1</p></blockquote><p>sb题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 2020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mkp make_pair</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="built_in">deque</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q ;</span><br><span class="line"><span class="keyword">int</span> T, N, M, i, j, dis[MAXN][MAXN] ; <span class="keyword">char</span> base[MAXN][MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    dis[<span class="number">1</span>][<span class="number">1</span>] = <span class="number">0</span> ; q.push_front(mkp(<span class="number">1</span>, <span class="number">1</span>)) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> x = q.front().first, y = q.front().second ; q.pop_front() ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; ++ i) &#123;</span><br><span class="line">            <span class="keyword">register</span> <span class="keyword">int</span> kx = x + dx[i], ky = y + dy[i] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt; <span class="number">1</span> || kx &gt; N || ky &lt; <span class="number">1</span> || ky &gt; M) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (dis[kx][ky] &gt; dis[x][y] + (base[x][y] != base[kx][ky])) </span><br><span class="line">                dis[kx][ky] = dis[x][y] + (base[x][y] != base[kx][ky]), </span><br><span class="line">                (base[x][y] == base[kx][ky]) ? q.push_front(mkp(kx, ky)) : q.push_back(mkp(kx, ky)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;N, &amp;M) ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; base[i][j] ;</span><br><span class="line">        bfs() ; <span class="built_in">cout</span> &lt;&lt; dis[N][M] &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-CF1063B-Labyrinth"><a href="#2-CF1063B-Labyrinth" class="headerlink" title="$2$ CF1063B Labyrinth"></a>$2$ CF1063B Labyrinth</h1><blockquote><p>你正在玩一款电脑游戏。<br>在其中一关，你位于一个 n行 m 列的迷宫。每个格子要么是可以通过的空地，要么是障碍。迷宫的起点位于第 r 行第 c列。你每一步可以向上、下、左、右中的一个方向移动一格，前提是那一格不是障碍。你无法越出迷宫的边界.<br>不幸的是，你的键盘快坏了，所以你只能向左移动不超过x格，并且向右移动不超过 y格。因为上下键情况良好，所以对向上和向下的移动次数没有限制。现在你想知道在满足上述条件的情况下，从起点出发，有多少格子可以到达（包括起点）？</p></blockquote><hr><p>嗯，一道很好的题。其实就是考虑我们如果从$(x,y)$出发，到达$(ex,ey)$，向右步数越少向左部署就越少（操作互相抵消）。</p><p>所以直接左右移动的边权设置为1，上下设置为0，跑BFS即可。观察这样做的合理性：只有左右有限制，所以最后对于每个点check一下就好。</p><p>不知道是不是因为网格图，SPFA在这种题上疯狂fst。。233</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; now ;</span><br><span class="line"><span class="keyword">int</span> N, M ; <span class="keyword">char</span> In[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line"><span class="keyword">int</span> dy[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125; ;<span class="comment">// </span></span><br><span class="line"><span class="built_in">deque</span> &lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt; q ; <span class="keyword">int</span> ans, i, j ;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">map</span>[MAXN][MAXN] ; <span class="keyword">int</span> dis[MAXN][MAXN], L, R, sx, sy ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)) ;</span><br><span class="line">    dis[sx][sy] = <span class="number">0</span> ; q.push_front(mkp(sx, sy)) ;</span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        now = q.front() ; q.pop_front() ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; <span class="number">4</span> ; ++ i)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = now.first + dx[i], ky = now.second + dy[i] ;</span><br><span class="line">            <span class="keyword">if</span> (kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || kx &gt; N || ky &gt; M || !<span class="built_in">map</span>[kx][ky]) <span class="keyword">continue</span> ; </span><br><span class="line">            <span class="keyword">if</span> (dis[kx][ky] &gt; dis[now.first][now.second] + (i == <span class="number">2</span>))</span><br><span class="line">                dis[kx][ky] = dis[now.first][now.second] + (i == <span class="number">2</span>), </span><br><span class="line">                (i != <span class="number">2</span>) ? q.push_front(mkp(kx, ky)) : q.push_back(mkp(kx, ky)) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; sx &gt;&gt; sy &gt;&gt; L &gt;&gt; R ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; (In + <span class="number">1</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            <span class="keyword">if</span> (In[j] == <span class="string">'.'</span>) <span class="built_in">map</span>[i][j] = <span class="number">1</span> ;  </span><br><span class="line">    &#125;</span><br><span class="line">    bfs() ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (dis[i][j] &lt; <span class="number">0</span>) <span class="keyword">continue</span> ;</span><br><span class="line">            <span class="keyword">if</span> (dis[i][j] &lt;= L &amp;&amp; j - sy + dis[i][j] &lt;= R) ++ ans ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>诶，又水一篇文章诶qwq。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$\text{0-1BFS}$本质上是一种特殊的图，它的边权有$1$和$0$两种。同时为了保持$BFS$状态单调的特性，使用&lt;strong&gt;0权头入、1权尾入&lt;/strong&gt;的入队方式。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>随想九·意义</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/18/Nine/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/18/Nine/</id>
    <published>2019-07-18T05:52:01.000Z</published>
    <updated>2019-07-19T12:15:07.226Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Let’s say sunshine for everyone 人们说生活总是充满阳光<br>But as far as I can remember 但在我的记忆中<br>We’ve been migratory animals 我们一直只是如野兽般流浪<br>Living under changing weather 四季变换，我们如常<br>Someday we will foresee obstacles 总有一天，我们会看见那些困难阻碍<br>Through the blizzard through the blizzard 在那片风雪之中，在那片风雪之后<br>Today we will sell our uniform 如今我们将曾经的校服变卖<br>Live together live together 一同离去，一同启程</p></blockquote>        <div id="aplayer-szXKQRbs" class="aplayer aplayer-tag-marker" style="margin-bottom: 20px;">            <pre class="aplayer-lrc-content"></pre>        </div>        <script>          var ap = new APlayer({            element: document.getElementById("aplayer-szXKQRbs"),            narrow: false,            autoplay: false,            showlrc: false,            music: {              title: "Obstacles",              author: "Syd Matters",              url: "Obstacles.flac",              pic: "/blog/2019/07/18/Nine/lis.png",              lrc: ""            }          });          window.aplayers || (window.aplayers = []);          window.aplayers.push(ap);        </script><h1 id="1"><a href="#1" class="headerlink" title="$1$"></a>$1$</h1><p>最近暑假了，一直颓的很。并不想说太多，每天晚上昏睡之际眼前的火苗会在第二天早上太阳升起时熄灭，似乎也不再是什么稀罕事。不过倒是也有所收获。先是去B站看<code>C菌</code>的《奇异人生二·实况》，才知道有《Life is Strange》这么一款游戏，于是索性只看了《二》，自己从steam上买了第一部，津津有味地玩了起来。奈何CPU是1.8GHz的，仅达到了最低配的要求，故画面体验有些差，但倒也无妨。但或许游戏时长有点多？别人都说“15小时通关”，似乎我也是在拽平均分了。</p><p><img src="1.png" alt></p><p>奇怪的是一直没有官方的的汉化包（但是2和续作都有汉化包，只有1官方没发布），于是只能凭很渣的英语阅读能力来玩，中间自然也是和看《哈利波特》一样，有许多细节是看不懂的，但是95%+还是没有问题。可惜玩完之后，毕竟是12 P.M.了，不知是真的出于困倦，亦或是别的原因，我并没有什么特别的感觉，大概就是“啊，结束了”便没了后文。</p><p>之后的一天半<strong>全</strong>用来看韩剧《秘密森林》，豆瓣上9分+的悬疑力作，确实不错；但是看完到现在似乎已经过了10个小时多，自己却一点深刻的感觉也没有，仅仅也是“啊，结束了”。我逼自己在脑海里构思出过几个结论，诸如“剧情好，情节紧凑”、“主角们身上的品质值得学习”之类的老套的东西，毕竟自己不喜欢接受“我浪费了时间”这种事实。</p><p>但是我从QQ音乐上（我一直不用网易云）搜到了Life is Strange的soundtrack，听了听最后选择Cloye后的BGM，或者说谢场曲，<code>Obstacles</code>，渐渐地有了感觉。这时我才意识到，或许这真是一款伟大的游戏。</p><h1 id="2"><a href="#2" class="headerlink" title="$2$"></a>$2$</h1><p>到现在我才发现，一个真正的爱的东西，或许一张照片就能表达，不许要各个角度的拍摄、点缀——此感慨大概是来源于我本来想把自己很有感触的片段啊、镜头啊、台词啊都整理出来，丢到博客上封存起来。但碍于自己实力不够又太懒，最终决定放弃了。当然，或许这个感慨也仅是一个心理安慰而已吧。</p><p>不知怎的，最近无论做什么事都有种“却道天凉好个秋”的感觉。纵然坐在屏幕前，单曲循环着<code>Obstacles</code>的我心中不断闪回无数个游戏中的镜头，我从来没意识到的感动、满足在心中游动，我却只想淡淡地描述它，仿佛真的有什么东西一说出口，就会化作烟云飘飞走，再也不回。</p><p>最后我选择了Cloye，毫不犹豫地，毁掉了小镇。大概是太感性了吧，看着C菌玩出的拯救小镇的结局最后，棺材上翩翩落下的那只蓝蝴蝶和最后的Max的笑，我感到一阵目眩。经过了23个小时的奋战，我仿佛已经和Max融为了一体：我会感叹超能力滥用的危害，我看着Cloye开心的样子自己也会喜不自胜，看到游戏中周围的场景也恨不得赶紧拍一张，也十分想拥有和Max一样的书画方式，句里话间贯穿着充满浓郁美国西部风味的笑话，但却永远不失简约和得体。我感叹自己身为Max所经历的一切，不断变换的结局，不断迎来的挑战，直到最后才发现可以改变事实的自己有多么无力，才发现Cloye活着才是我唯一想要的。无论最后Cloye是否为此牺牲了，我都会很感慨和Cloye在一起厮混、感慨我成功救下了Kate，感慨自己房间的小清新和Cloye房间的独特，感慨Max和Cloye的那种爱情和友情不断相互叠加，创造出的那种至美至真的情感。</p><p>整体上来看，这应该是个悲伤的故事——无论选哪种结局。但是或许也只有悲剧会把生活中的美好撕碎给人看，之后人们才会从那些碎片里面重新拾起向前走的动力吧。</p><p>我很想和Max和Cloye做朋友。那一定是一件很幸福的事情吧。</p><h1 id="3"><a href="#3" class="headerlink" title="$3$"></a>$3$</h1><p>从现在开始，我开始很惧怕看一部新剧或者玩一部新的游戏。我害怕情节会太妙、人物会太精致导致我沉浸其中无法自拔，正如我看《哈利波特》、我看《言叶之庭》、我玩《生化危机7》、我玩Life is Strange一样，要缓好几天才能缓过来。我会泄气为什么我的生活没有那么多缤纷的元素——没有魔法、没有值得我守护的东西、没有改变时间的超能力、没有跨越鸿沟的极致爱情；我会感慨为什么我没有主人公那种超凡脱俗的品质、惊人的意志或者优秀的人际关系。仿佛每多一部文学作品，就如同我心底黑暗的夜空多了一颗星点，但我却只能蜷缩在远处黑暗的角落，瑟瑟地发着抖，看着天空中的光芒我竟会觉得刺眼，觉得避之不及。不知道什么时候，我连欣赏美好的能力都没了。</p><p>确实，虽然上文提到的<code>Obstacles</code>这支歌确实是Life is Strange在我心中最完美的诠释，但是我毫不留情面地把它移出了我的曲库。不在于别的，只是因为我不想再一听某首歌就有想哭的冲动，不想再听一首歌就感到自己有多么孤独。rqy口中的“早在心里哭过了”或许就是这种感觉吧。</p><p>我又能做什么呢？无论周围有多少人跟我成天开玩笑啊、斗嘴啊，我真的把他们打心底当作过理解我的人吗？我感觉自己每天就如同一座空壳一样，行尸走肉般地担心着一切。大概我是很难把心敞开给谁的把，或者即使我敞开了我也不认为自己敞开了吧；以此为理由说“大概是因为没有另一半造成的”，也不过是病急乱投医吧。我就仿佛一只迷途的小船，永远不知道自己的下一站在哪里。-</p><p>其实说到底，还是我根本不知道如何去生活。之前积累的浮躁让我不知道该如何面对平常人的生活，来到高中之后我才知道“哦，原来努力才是硬道理”。或许是rqy太强了，强到他的光芒洒在我眼前时会让我有种我也可以轻松到达那个高度的错觉——整个高一仿佛只有最后一星期不是浮躁的。</p><p>或许，我一直是个很好的$\rm{Admirator}$  (羡慕者)而不是一个好的$\rm{Doer}$(实践者)吧。</p><h1 id="4"><a href="#4" class="headerlink" title="$4$"></a>$4$</h1><p>我一直想知道自己现在到底为何而活，活的意义又是什么。</p><p>放眼四周全是烟雾弥漫，我畏惧了。</p><p>或许只要我强一些，在文化课上、或者在奥赛上取得了骄人的成绩我就可以全身心投入其中一者了。但奈何实力不足，两者都不是我的拿手项。我开始慌了。之前的岁月仿佛都是虚度，自己去年多么弱，今年似乎也并没有什么实质的变化。我开始慌了。</p><p>大家都说“不能功利地搞OI啊”，周围mcfx、rqy的成功也都反复论证了这一点。但是我，我…对我而言，似乎没有比这个更高的精神动力了啊。周围异样的目光接踵而来，因为我不是强者，不可能说出什么“走自己的路，让别人说去吧”的豪言壮语——按着传统的步调都不能取胜，自己的步调大概只是飞蛾扑火吧。</p><p>我似乎觉得有些奇怪，大概自己本来就不是搞OI的人，或许是个文学家更合适；但是看到期末考试惨不忍睹的语文分数，我又迷茫了；大概自己本来就没有多努力，但是我感觉今年省选前自己已经够努力了啊，或许只是方向错了——但是方向又在哪呢，我又迷茫了。</p><p>似乎天地之大，只有我一个人整日沉浸在迷茫之中无法脱身：人与人真是不一样啊。有些人就是可以无问西东、敢想敢干；我则只会是一个杂鱼，睡死在漫无边际的冬日。</p><p>每到这个时候，我都好想逃跑，我想跑到Max和Cloye的那个小镇，和他们一起无忧无虑地活着，没有文化课的压力，没有升学的压力，没有豪言壮语的压力，没有OI的压力，就只是简单地活着……最重要的，我可以不思考我为何而活。</p><p>当然，以上都是一个高中生的无病呻吟而已。说到底，我还是没有任何勇气的蝼蚁，不知道该怎样直面生活的痛击，不知道如何自在地活，敏感，而颓废。</p><blockquote><p>除了勇气，我什么都不缺。</p></blockquote><p>Life is Strange，Max，Cloye，寄托着的，是我遥不可及的一个梦啊。</p><p><img src="2.png" alt></p><h1 id="5"><a href="#5" class="headerlink" title="$5$"></a>$5$</h1><p>终于我要重新上路了，过去的快乐我想抹去，过去的心酸我想埋葬。眼泪垂青过的土地是翻上来的新泥，在心里死了好几次也必须重生。</p><p>至于文学作品，我能想到的最好的结束便是如下：</p><blockquote><p>或许，<br>每一份精致的艺术作品都是一个有条不紊的世界；<br>有关那个世界的回忆，不如折叠起来，就留在那个世界吧。</p></blockquote><p>是啊，Max和Cloye的故事，就留给阿卡迪亚湾和他们即将抵达的西雅图吧；秋月孝雄和雪野百香里的故事就留在那个古色古香的雨亭吧。一切的一切都是碎片，在时空里面穿行，倏而消失不见，倏而又出现在我眼前。铭记和沉沦没有意义；这个世界的一切，无论多么无聊与不可期待，明天太阳升起时，便还要继续。</p><p>意义？似乎意义这东西本身就是没有意义的。理解生命、理解生活反而是某种屈从，而真正的英雄则是命运的斗士——就好像JO5里面的主角们，坚定地举起反抗命运的大旗。</p><p>明日是否如同今日一样沉沦？我不知道。我只知道把握住下一秒就足够了。之前的生活的每一帧仿佛都像是飘在空中的泡影而已，洗刷着存在于虚妄中的记忆，一次一次，如同枷锁一样阻遏着我的前进。</p><p>所以，请君勿言什么明天更好之类的P话了，在绝望中求生才是人生的常态。就如同从峭壁中生出的兰花，挤落一捻石尘都是成功。</p><hr><p>《随想》系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">$Link$</a></p>]]></content>
    
    <summary type="html">
    
      意义？
    
    </summary>
    
      <category term="Life" scheme="https://Flower233pks.github.io/blog/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://Flower233pks.github.io/blog/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Old-NOIP 泛做二</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/11/Old-NOIP2/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/11/Old-NOIP2/</id>
    <published>2019-07-11T10:39:51.000Z</published>
    <updated>2019-07-25T10:10:21.046Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>事实上我不久前才发现原来NOIP里面的一些题是很好的……</p><p>然后大概接下来整理的都是些我认为挺有难度的吧qwq</p><p>但是感觉似乎这么好的题放在一块有点憋屈……于是就缩短了篇幅增多了篇目</p><h1 id="1-2011F-观光公交"><a href="#1-2011F-观光公交" class="headerlink" title="$~1~2011F$ 观光公交"></a>$~1~2011F$ 观光公交</h1><p><a href="https://www.luogu.org/problem/P1315" target="_blank" rel="noopener">$Link$</a></p><p>这题我还是去年的3月19号做的，显然是抄的题解，于是现在又要重做一遍/sad</p><p>那么其实贪心的思路很简单，找最多人经过的那条路。由于$n$是$1000$所以直接$O(nk)$的暴力就很稳了。然后注意消除后效性——大体上就是如果你这一站用了什么“氮气加速”，结果下一站还得在那等着，就没有任何作用了，这种情况就<code>gg[i]=i+1</code>，你只能拯救下一站下车的乘客；否则你也可以拯救更多的，就是<code>gg[i]=gg[i+1]</code>，也算是一种状态转移的思想吧。在我看来似乎这是本题唯一的难点了……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">person</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> w,f,t;</span><br><span class="line">&#125;p[<span class="number">100001</span>];</span><br><span class="line"><span class="keyword">int</span> max_each[<span class="number">100001</span>],sum_max[<span class="number">100001</span>],get[<span class="number">100001</span>],time[<span class="number">100001</span>],gg[<span class="number">100001</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,m,k,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n<span class="number">-1</span>;i++)<span class="built_in">cin</span>&gt;&gt;time[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;p[i].w&gt;&gt;p[i].f&gt;&gt;p[i].t;</span><br><span class="line">    max_each[p[i].f]=max(p[i].w,max_each[p[i].f]);</span><br><span class="line">        sum_max[p[i].t]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)sum_max[i]+=sum_max[i<span class="number">-1</span>];</span><br><span class="line">get[<span class="number">1</span>]=max_each[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)get[i]=max(get[i<span class="number">-1</span>],max_each[i<span class="number">-1</span>])+time[i<span class="number">-1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">register</span> <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;ans+=(get[p[i].t]-p[i].w);&#125;<span class="comment">//cout&lt;&lt;ans&lt;&lt;endl;</span></span><br><span class="line"><span class="keyword">while</span>(k--)&#123;</span><br><span class="line">        gg[n]=gg[n<span class="number">-1</span>]=n;</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">0</span>,f;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=n<span class="number">-2</span>;i&gt;=<span class="number">1</span>;i--)</span><br><span class="line">        gg[i]=get[i+<span class="number">1</span>]&lt;=max_each[i+<span class="number">1</span>]?i+<span class="number">1</span>:gg[i+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">        <span class="keyword">if</span>(sum_max[gg[i]]-sum_max[i]&gt;maxn&amp;&amp;time[i])&#123;</span><br><span class="line">            maxn=sum_max[gg[i]]-sum_max[i];f=i;</span><br><span class="line">        &#125;</span><br><span class="line">        ans-=maxn;time[f]--;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)get[i]=max(get[i<span class="number">-1</span>],max_each[i<span class="number">-1</span>])+time[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>拿什么拯救我当年幼稚的码风啊</del></p><h1 id="2-2015C-斗地主"><a href="#2-2015C-斗地主" class="headerlink" title="$2~2015C$ 斗地主"></a>$2~2015C$ 斗地主</h1><p><a href="https://www.luogu.org/problem/P2668" target="_blank" rel="noopener">Link</a></p><p>一道喜闻乐见的搜索题。其实蛮简单的，就是每次把能出的牌出一遍就好了，就是调有点难调，在这个时候输出调试法+肉眼查错法比什么<code>gdb</code>好用多了。</p><p>以下是整理的细节：</p><ul><li>至于如何出单牌和对子，只需要每次dfs时每次最后把不能出花的都出了就好，就是这样：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">14</span> ; ++ j) <span class="keyword">if</span> (buc[j]) step ++ ; Ans = min(Ans, step) ; <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure><pre><code>反之如果在出单牌/对子的时候再设置回溯——没有必要且严重扩展了状态数。</code></pre><ul><li>还是剪枝，大概就是一个最优性剪枝：<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ;</span><br></pre></td></tr></table></figure></li></ul><p>​    可能是因为太套路了我一直记不住= =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ; </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//单顺子 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">      <span class="keyword">if</span> (!buc[j + k - <span class="number">1</span>] || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">        cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= <span class="number">5</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -- ;</span><br><span class="line">dfs(m - cnt, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//双顺子 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">      <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">2</span> || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">         cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">     &#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">2</span> ;</span><br><span class="line">dfs(m - cnt * <span class="number">2</span>, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//三顺子 </span></span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">      <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">3</span> || j + k &gt; <span class="number">13</span>) &#123; </span><br><span class="line">        cnt = k - <span class="number">1</span> ; pos = j + k - <span class="number">2</span> ; <span class="keyword">break</span> ; </span><br><span class="line">      &#125;</span><br><span class="line"><span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">3</span>  ;</span><br><span class="line">dfs(m - cnt * <span class="number">3</span>, step + <span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j)&#123; <span class="comment">//炸弹 or 四带二  </span></span><br><span class="line"> <span class="keyword">int</span> p[<span class="number">3</span>], tot = <span class="number">0</span>, q[<span class="number">3</span>], cnt = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">if</span> (buc[j] &gt;= <span class="number">4</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">14</span> ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (j != k)&#123;</span><br><span class="line"><span class="keyword">if</span> (buc[k] &gt;= <span class="number">2</span> &amp;&amp; cnt &lt; <span class="number">2</span>) q[++ cnt] = k ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (buc[k] &amp;&amp; tot &lt; <span class="number">2</span>) p[++ tot] = k ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">if</span> (tot &lt; <span class="number">2</span> &amp;&amp; cnt &lt; <span class="number">2</span>) &#123; buc[j] -= <span class="number">4</span> ; dfs(m - <span class="number">4</span>, step + <span class="number">1</span>) ; buc[j] += <span class="number">4</span> ; &#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (cnt &lt; <span class="number">2</span>)  &#123; </span><br><span class="line">        buc[p[<span class="number">2</span>]] --, buc[p[<span class="number">1</span>]] --, buc[j] -= <span class="number">4</span> ; </span><br><span class="line">        dfs(m - <span class="number">6</span>, step + <span class="number">1</span>) ; buc[p[<span class="number">2</span>]] ++, buc[p[<span class="number">1</span>]] ++, buc[j] += <span class="number">4</span> ; </span><br><span class="line">      &#125;</span><br><span class="line"> <span class="keyword">else</span> &#123; </span><br><span class="line">        buc[q[<span class="number">2</span>]] -= <span class="number">2</span>, buc[q[<span class="number">1</span>]] -= <span class="number">2</span>, buc[j] -= <span class="number">4</span> ; </span><br><span class="line">        dfs(m - <span class="number">8</span>, step + <span class="number">1</span>) ; buc[q[<span class="number">2</span>]] += <span class="number">2</span>, buc[q[<span class="number">1</span>]] += <span class="number">2</span>, buc[j] += <span class="number">4</span> ; &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j)&#123; <span class="comment">// 三带XXX </span></span><br><span class="line"><span class="keyword">if</span> (buc[j] &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">buc[j] -= <span class="number">3</span> ;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">14</span> ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span>( !buc[k] || k == j )  <span class="keyword">continue</span> ;</span><br><span class="line">                buc[k] -- ; dfs(m - <span class="number">4</span>, step + <span class="number">1</span>) ; buc[k] ++ ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">13</span> ; ++ k)&#123;</span><br><span class="line">                <span class="keyword">if</span>( buc[k] &lt;= <span class="number">1</span> || j == k) <span class="keyword">continue</span> ;</span><br><span class="line">                buc[k] -= <span class="number">2</span> ; dfs(m - <span class="number">5</span>, step + <span class="number">1</span>) ; buc[k] += <span class="number">2</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            buc[j] +=<span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">14</span> ; ++ j) <span class="keyword">if</span> (buc[j]) step ++ ; Ans = min(Ans, step) ; <span class="keyword">return</span> ;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>= =其实这题最恶心的还是粗心地写错，毕竟那么多函数都是<code>ctrl c</code>+<code>ctrl v</code>的，鬼知道什么地方就崩掉了……</p><h1 id="3-2015-text-C-G-斗地主加强版"><a href="#3-2015-text-C-G-斗地主加强版" class="headerlink" title="$3~2015\text{C+/G}$  斗地主加强版"></a>$3~2015\text{C+/G}$  斗地主加强版</h1><p><a href="https://www.luogu.org/problem/P2540" target="_blank" rel="noopener">Link</a></p><p>直接粘一份代码过来你甚至可以获得74pts的好成绩= =</p><p>其实主要思想就是<strong>拆牌</strong>，原因是假设你又两组三张，一组炸，你的思路是出三次，但实际上只需要两次就可以——把一组三张拆成一单+一对，然后带走只需要两次。</p><p>但是我并不想写诡异的剪枝，于是索性根据题解区写了一个DP。即设$dp_{i,j,k,l,o}$表示剩下的单张有$i$个，对牌有$j$个，三张有$k$组，四张有$l$组，王有$o$个的最小出牌次数。然后转移就是朴素的转移，同时由于拆牌的存在，我们需要多加两组拆牌的转移，这就需要我们先枚举三张和炸才能转移。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init_dp</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> l = <span class="number">0</span> ; l &lt;= N ; ++ l)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt;= N ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt;= N ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> o = <span class="number">0</span> ; o &lt;= <span class="number">2</span> ; ++ o)&#123;</span><br><span class="line">rr <span class="keyword">int</span> res = <span class="number">100</span> ;</span><br><span class="line"><span class="comment">// Single</span></span><br><span class="line"><span class="keyword">if</span> (i) res = min(res, dp[i - <span class="number">1</span>][j][k][l][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (j) res = min(res, dp[i][j - <span class="number">1</span>][k][l][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (k) res = min(res, dp[i][j][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (l) res = min(res, dp[i][j][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (o) res = min(res, dp[i][j][k][l][o - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (o &gt; <span class="number">1</span>) res = min(res, dp[i][j][k][l][o - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">// T -&gt; 1</span></span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; k) res = min(res, dp[i - <span class="number">1</span>][j][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (k &amp;&amp; o) res = min(res, dp[i][j][k - <span class="number">1</span>][l][o - <span class="number">1</span>] + <span class="number">1</span>) ; </span><br><span class="line"><span class="comment">// T -&gt; 2</span></span><br><span class="line"><span class="keyword">if</span> (j &amp;&amp; k) res = min(res, dp[i][j - <span class="number">1</span>][k - <span class="number">1</span>][l][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">// F -&gt; 2</span></span><br><span class="line"><span class="keyword">if</span> (l &gt; <span class="number">1</span>) res = min(res, dp[i][j][k][l - <span class="number">2</span>][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (j &amp;&amp; l)  res = min(res, dp[i][j - <span class="number">1</span>][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i - <span class="number">2</span>][j][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (j &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i][j - <span class="number">2</span>][k][l - <span class="number">1</span>][o] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (o &gt; <span class="number">1</span> &amp;&amp; l) res = min(res, dp[i][j][k][l - <span class="number">1</span>][o - <span class="number">2</span>] + <span class="number">1</span>) ;</span><br><span class="line"><span class="keyword">if</span> (i &amp;&amp; o &amp;&amp; l) res = min(res, dp[i - <span class="number">1</span>][j][k][l - <span class="number">1</span>][o - <span class="number">1</span>] + <span class="number">1</span>) ;</span><br><span class="line"><span class="comment">// CHAI</span></span><br><span class="line"><span class="keyword">if</span> (l) res = min(res, dp[i + <span class="number">1</span>][j][k + <span class="number">1</span>][l - <span class="number">1</span>][o]) ;</span><br><span class="line"><span class="keyword">if</span> (k) res = min(res, dp[i + <span class="number">1</span>][j + <span class="number">1</span>][k - <span class="number">1</span>][l][o]) ;</span><br><span class="line"><span class="comment">// Trans</span></span><br><span class="line">dp[i][j][k][l][o] = min(res, dp[i][j][k][l][o]) ;</span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拆牌分别是“炸拆成三张和单张”以及“三张拆成对子和单张”。</p><p>然后由于顺子这种东西不能根据数量转移，所以就还是dfs暴力算（dp按理说也是暴力吧/kk），最后加回来就完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step &gt;= Ans) <span class="keyword">return</span> ; </span><br><span class="line"> <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//单顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k) </span><br><span class="line">          <span class="keyword">if</span> (!buc[j + k - <span class="number">1</span>] || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">5</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">5</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">           <span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= j + p - <span class="number">1</span> ; ++ k) buc[k] -- ;</span><br><span class="line">            dfs(m - p, step + <span class="number">1</span>) ;   </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= j + p - <span class="number">1</span> ; ++ k) buc[k] ++ ;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//双顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">          <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">2</span> || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">3</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">3</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">            pos = j + p - <span class="number">1</span> ; </span><br><span class="line">              <span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">2</span> ;</span><br><span class="line">            dfs(m - cnt * <span class="number">2</span>, step + <span class="number">1</span>) ; </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">2</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">12</span> ; ++ j)&#123; <span class="comment">//三顺子 </span></span><br><span class="line">        rr <span class="keyword">int</span> cnt = <span class="number">0</span>, pos ;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; ; ++ k)  </span><br><span class="line">          <span class="keyword">if</span> (buc[j + k - <span class="number">1</span>] &lt; <span class="number">3</span> || j + k &gt; <span class="number">13</span>) &#123; cnt = k - <span class="number">1</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt &gt;= <span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">for</span> (rr <span class="keyword">int</span> p = <span class="number">2</span> ; p &lt;= cnt ; ++ p)&#123;</span><br><span class="line">            pos = j + p - <span class="number">1</span> ; </span><br><span class="line">              <span class="keyword">for</span> (rr <span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] -= <span class="number">3</span> ;</span><br><span class="line">            dfs(m - cnt * <span class="number">3</span>, step + <span class="number">1</span>) ; </span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> k = j ; k &lt;= pos ; ++ k) buc[k] += <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">memset</span>(tong, <span class="number">0</span>, <span class="keyword">sizeof</span>(tong)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">13</span> ; ++ j) tong[buc[j]] ++ ; tong[<span class="number">5</span>] = buc[<span class="number">14</span>] ;</span><br><span class="line">    Ans = min(Ans, step + dp[tong[<span class="number">1</span>]][tong[<span class="number">2</span>]][tong[<span class="number">3</span>]][tong[<span class="number">4</span>]][tong[<span class="number">5</span>]]);<span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-2015E-子串"><a href="#4-2015E-子串" class="headerlink" title="$4~2015E$ 子串"></a>$4~2015E$ 子串</h1><p><a href="https://www.luogu.org/problem/P2679" target="_blank" rel="noopener">$Link$</a></p><p>又是一道情怀题，还记得当时做的时候觉得可难了…（当时的pks：这个转移是人能想出来的吗？）</p><p>但其实状态很简单，$f_{i,j,k,0/1}$记录A到了$i$，B到了$j$，A迄今为止分成$k$段，$A[i]$选或者不选的方案数。</p><p>然后转移时考虑分类讨论：</p><ul><li><p>首先  $A[i] = B[j]:$</p><ul><li>1 ： $f_{i,j,k,1} = f_{i-1,j-1,k-1,1} + f_{i-1,j-1,k-1,0} + f_{i-1,j-1,k,1}$ 也就是{i,j}和前面的是一段/不是一段且和前面的段之间有空格/不是一段且和前面的段之间没空格（讨论空格是为了保证转移的完整性）。</li><li>2 ： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$ 前面一位选/不选</li></ul></li><li><p>否则 $A[i]\not = B[j]$</p><ul><li>1：  $f_{i,j,k,1} = 0\\$ 不合法的转移<br>2： $f_{i,j,k,0} = f_{i - 1,j, k, 1} + f_{i -1, j, k, 0}$</li></ul></li></ul><p>其实感觉这个方程…怎么说呢，挺有学习意义的。这其实也算是做了一个状态的前缀和，因为理论上是要从$k\text{~}i-1$中转移的，但因为是方案数，所以可以直接做一个前缀和过来；同时因为此时我们的“主元”是$A$，所以如果不选的话只能是从$(i-1,j)$转移过来而不是$(i,j-1)$（即$k$这一维限制的是$i$） 。</p><p>然而还有另外一种定义状态的方式；</p><p>其余的都差不多，还是$f_{i,j,k,1}$表示必选，但是$f_{i,j,k,0}$则表示<strong>“可选可不选”</strong>。那我们来思考这样如何转移：</p><ul><li>1：$f_{i,j,k,1} = (f_{i-1,j-1,k,1} +f_{i - 1,j-1, k-1, 0})\cdot [A_i=B_j] $ 还是分类讨论“连不连成一整段”</li><li>2：$f_{i,j,k,0} = f_{i−1,j,k,0}+f_{i,j,k,1}$，即<strong>保证了这一位不选的上一位的选/不选</strong>和<strong>保证了这一位必选</strong>的方案数。</li></ul><p>思想也大体相同。注意数据范围的限制，滚一下就好了。</p><p>嗯，是一道不错的题。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++) <span class="built_in">cin</span> &gt;&gt; A[i] ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++) <span class="built_in">cin</span> &gt;&gt; B[i] ;</span><br><span class="line">    <span class="keyword">for</span>(d = i = <span class="number">1</span>; i &lt;= N; i ++, d ^= <span class="number">1</span>)&#123;</span><br><span class="line">        dp[d][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>; j &lt;= M; j ++)</span><br><span class="line">            <span class="keyword">for</span>(k = <span class="number">1</span>; k &lt;= K ;k ++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j]) </span><br><span class="line">                f[d][j][k] = (dp[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k - <span class="number">1</span>] + f[d ^ <span class="number">1</span>][j - <span class="number">1</span>][k]) % mod ;</span><br><span class="line">                <span class="keyword">else</span> f[d][j][k] = <span class="number">0</span> ; </span><br><span class="line">              dp[d][j][k] = (dp[d ^ <span class="number">1</span>][j][k] + f[d][j][k]) % mod ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[N &amp; <span class="number">1</span>][M][K]% mod ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="5-2011C-Mayan游戏"><a href="#5-2011C-Mayan游戏" class="headerlink" title="$5~2011C$ Mayan游戏"></a>$5~2011C$ Mayan游戏</h1><p><a href="https://www.luogu.org/problem/P1312" target="_blank" rel="noopener">Link</a></p><p>想当年这可真是噩梦……</p><p>简单来讲就是爆搜吧，只不过记得当时没想到是真的每次搜一遍$7\cdot5$的方阵……</p><p>然后这是以前的笔记：</p><ul><li>1、每次搜索要保留本次的状态，这是比较好想的，我也成功的想到了。但是问题是我们不能单纯地用一个二维数组来$copy$，需要记录步数，因为如果单纯的reset会导致之前走过的也消失。于是最终我们需要一个三维数组来记录。后半段是$qcr$告诉我的。 </li><li><p>2、还有就是一个小小的剪枝。就是由于对于每一个格子，我们考虑它向两边替换，而我们为了避免重复搜索，所以就决定<strong>单向搜索</strong>，即对于每个块，如果他左边也是一个块，那就不去$exchange$，只考虑右边；而如果左边是空白格，才$exchange$。显然这个剪枝的优化性是很显著的。</p></li><li><p>3、我一开始写的$remove()$、$down()$和$check()$十分的麻烦——或者说专一?反正之后我懒得调试了，直接听的$qcr$的，每次执行这几个函数的时候，直接<strong>全屏扫一遍</strong>。</p></li><li><p>4、$qcr$给我讲了一个很神的$down()$函数——其实也不算多神，只是很简单地处理了每一行的悬空态方块，但是说“神”的原因则是因为“简单”。对，简单，而有时往往我会想复杂。</p></li><li><p>5、对于$exchange$，我们要不断的$while(remove()) ~;$，因为会不断地有新情况出现。</p></li><li><p>6、最后我挂了……几个点来着……忘记了。反正原因是因为，每次$remove()$之前应该先$down()$，然而我并没有$down()$干净233</p></li><li><p>7、最后再说一个剪枝儿，不是必要性的，但是确实可以加快速度。就是我们再每次遍历$7 \times 5$的时候，遇到空白的，不是<code>continue</code>而是<code>break</code>，因为我们$down$一定是完备的，即从下向上枚举时，如果下方的已经clear了，上方的不可能悬空。所以可以少好几次空遍历。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span>&#123;</span> <span class="keyword">int</span> x, y ;&#125; ; <span class="built_in">stack</span> &lt;D&gt; s ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Ans</span>&#123;</span> <span class="keyword">int</span> x, y, d  ;&#125; res[<span class="number">100</span>] ; <span class="keyword">int</span> Remove[<span class="number">50</span>][<span class="number">50</span>] ;</span><br><span class="line"><span class="keyword">int</span> N, T[<span class="number">30</span>][<span class="number">30</span>], base[<span class="number">4000</span>][<span class="number">10</span>][<span class="number">10</span>], qwq[<span class="number">4000</span>][<span class="number">30</span>], color[<span class="number">30</span>], i, j, t, tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">down</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ttt = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)&#123;</span><br><span class="line">        ttt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            <span class="keyword">if</span>(T[di][dj] == <span class="number">-1</span>) ++ ttt ;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(! ttt) <span class="keyword">continue</span> ;</span><br><span class="line">                T[di][dj - ttt] = T[di][dj], T[di][dj] = <span class="number">-1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">()</span></span>&#123; <span class="comment">// void -&gt; bool</span></span><br><span class="line">    <span class="keyword">bool</span> Mark = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(Remove, <span class="number">0</span>, <span class="keyword">sizeof</span>(Remove)) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span> &amp;&amp; di &gt;= <span class="number">2</span> &amp;&amp; di &lt;= <span class="number">4</span> </span><br><span class="line">                &amp;&amp; T[di][dj] == T[di + <span class="number">1</span>][dj] &amp;&amp; T[di][dj] == T[di - <span class="number">1</span>][dj])&#123;</span><br><span class="line">                Remove[di + <span class="number">1</span>][dj] = Remove[di - <span class="number">1</span>][dj] = Remove[di][dj] = <span class="number">1</span>, </span><br><span class="line">                Mark = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span> &amp;&amp; dj &gt;= <span class="number">2</span> &amp;&amp; dj &lt;= <span class="number">6</span> </span><br><span class="line">                &amp;&amp; T[di][dj] == T[di][dj + <span class="number">1</span>] &amp;&amp; T[di][dj] == T[di][dj - <span class="number">1</span>])&#123;</span><br><span class="line">                Remove[di][dj + <span class="number">1</span>] = Remove[di][dj - <span class="number">1</span>] = Remove[di][dj] = <span class="number">1</span>, </span><br><span class="line">                Mark = <span class="number">1</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">if</span> (!Mark) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            T[di][dj] = (!Remove[di][dj]) ? T[di][dj] : <span class="number">-1</span> ;</span><br><span class="line">    down() ; <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">false</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Prepare</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="comment">//copy</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            base[x][di][dj] = T[di][dj] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _reset(<span class="keyword">int</span> x)&#123;<span class="comment">//copy_back</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)</span><br><span class="line">            T[di][dj] = base[x][di][dj] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs_work</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (judge())&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= N ; ++ di)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d %d %d\n"</span>, res[di].x, res[di].y, res[di].d) ;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (step == N + <span class="number">1</span>) <span class="keyword">return</span> ; Prepare(step) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> di = <span class="number">1</span> ; di &lt;= <span class="number">5</span> ; ++ di)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dj = <span class="number">1</span> ; dj &lt;= <span class="number">7</span> ; ++ dj)&#123;</span><br><span class="line">            <span class="keyword">if</span> (T[di][dj] == <span class="number">-1</span>) <span class="keyword">break</span> ;</span><br><span class="line">            <span class="keyword">if</span> (di &gt; <span class="number">1</span> &amp;&amp; T[di - <span class="number">1</span>][dj] == <span class="number">-1</span>)&#123;</span><br><span class="line">                swap(T[di][dj], T[di - <span class="number">1</span>][dj]) ; down() ; <span class="keyword">while</span> (remove()) ;</span><br><span class="line">                res[step] = (Ans)&#123;di - <span class="number">1</span>, dj - <span class="number">1</span>, <span class="number">-1</span>&#125; ; </span><br><span class="line">                dfs_work(step + <span class="number">1</span>) ; _reset(step) ; res[step] = (Ans)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (di &lt; <span class="number">5</span> &amp;&amp; T[di][dj] != T[di + <span class="number">1</span>][dj])&#123;</span><br><span class="line">                swap(T[di][dj], T[di + <span class="number">1</span>][dj]) ; down() ; <span class="keyword">while</span>(remove()) ;</span><br><span class="line">                res[step] = (Ans)&#123;di - <span class="number">1</span>, dj - <span class="number">1</span> ,<span class="number">1</span>&#125; ; </span><br><span class="line">                dfs_work(step + <span class="number">1</span>) ; _reset(step) ; res[step] = (Ans)&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125; ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="built_in">memset</span>(T, <span class="number">-1</span>, <span class="keyword">sizeof</span>(T)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">5</span> ; ++ i) T[i][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">5</span> ; ++ i)</span><br><span class="line">        <span class="keyword">while</span>((t = qr()) != <span class="number">0</span>) T[i][++ T[i][<span class="number">0</span>]] = t ;</span><br><span class="line">    dfs_work(<span class="number">1</span>) ; <span class="built_in">cout</span> &lt;&lt; <span class="number">-1</span> &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="text-Afterwords"><a href="#text-Afterwords" class="headerlink" title="$\text{Afterwords}$"></a>$\text{Afterwords}$</h1><p>“</p><p>准确来说，没有人在到达之前知道自己到底要去哪儿。</p><p>”</p>]]></content>
    
    <summary type="html">
    
      $NOIP2016$以及之前年份$NOIP$中不是那么水的题目的泛做。
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="动态规划-普通DP" scheme="https://Flower233pks.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="NOIP系列" scheme="https://Flower233pks.github.io/blog/tags/NOIP%E7%B3%BB%E5%88%97/"/>
    
      <category term="搜索-剪枝" scheme="https://Flower233pks.github.io/blog/tags/%E6%90%9C%E7%B4%A2-%E5%89%AA%E6%9E%9D/"/>
    
      <category term="奇怪的技巧" scheme="https://Flower233pks.github.io/blog/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
      <category term="贪心" scheme="https://Flower233pks.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>Old-NOIP 泛做一</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/11/old-noip/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/11/old-noip/</id>
    <published>2019-07-11T10:39:51.000Z</published>
    <updated>2019-07-25T09:55:18.940Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>首先简介一下这篇文章的来历……</p><p>此时的我正在瞎翻之前做过的、看起来还可以的NOIP水题，觉得哪个地方值得注意就整了下来。然而实际上我是只想整理“泛做二”里的题目。不过一想似乎自己基础不扎实，于是才有了这篇水文。</p><h1 id="1-2013B-火柴排队"><a href="#1-2013B-火柴排队" class="headerlink" title="$1~2013B$ 火柴排队"></a>$1~2013B$ 火柴排队</h1><p><a href="https://www.luogu.org/problem/P1966" target="_blank" rel="noopener">Link</a></p><p>这真是个水题。但是之前做的时候没意识到一些问题，前几天翻来看看又把这个题秒了一遍。</p><p>观察整个式子，我们拆开之后就发现是在最小化$-\sum a_ib_i$，也就是最大化$\sum a_ib_i$。然后根据选修4-5里面的<strong>排序不等式</strong>，逆序和&lt;乱序和&lt;顺序和，直接找逆序对就好。</p><p><del>偷偷学数学真有用啊/kk</del></p><h1 id="2-2014C-飞扬的小鸟"><a href="#2-2014C-飞扬的小鸟" class="headerlink" title="$2 ~2014C$ 飞扬的小鸟"></a>$2 ~2014C$ 飞扬的小鸟</h1><p><a href="https://www.luogu.org/problem/P1941" target="_blank" rel="noopener">Link</a></p><p>……一道gou题。</p><p>当时全天下都知道状态$f_{i,j}$就我不会转移…背包其实挺显然的，上升的时候做完全背包，注意由于即使🐦在天花板里面($h= m$)时也可以跳，所以多转移几次， 且注意既可以从i-1转移过来，也可以从现在的i转移过来；下降的时候做反向值域的01背包。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ; ans = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;up[i], &amp;dw[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">      Wd[i][<span class="number">0</span>] = <span class="number">-1</span>, Wd[i][<span class="number">1</span>] = M + <span class="number">1</span> ; <span class="built_in">memset</span>(dp, <span class="number">63</span>, <span class="keyword">sizeof</span>(dp)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= K ; ++ i) </span><br><span class="line">      <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;k), S[k] = <span class="number">1</span>, <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;Wd[k][<span class="number">0</span>], &amp;Wd[k][<span class="number">1</span>]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= M ; ++ i) dp[<span class="number">0</span>][i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="comment">/*for (i = 2 ; i &lt;= N ; ++ i)</span></span><br><span class="line"><span class="comment">        for (j = Wd[i][0] + 1 ; j &lt; Wd[i][1] ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">            dp[i][j] = dp[i - 1][j + dw[i]] ;</span></span><br><span class="line"><span class="comment">            for (k = 0 ; k &lt;= (j - Wd[i - 1][0] - 1) / up[i] ; ++ k)</span></span><br><span class="line"><span class="comment">                dp[i][j] = min(dp[i - 1][j - k * up[i]] + k, dp[i][j]) ;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = up[i] + <span class="number">1</span> ; j &lt;= M + up[i] ; ++ j)</span><br><span class="line">            dp[i][j] = min(dp[i - <span class="number">1</span>][j - up[i]], dp[i][j - up[i]]) + <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = M + <span class="number">1</span> ; j &lt;= M + up[i] ; ++ j) </span><br><span class="line">          dp[i][M] = min(dp[i][M], dp[i][j]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= M - dw[i] ; j ++) </span><br><span class="line">          dp[i][j] = min(dp[i][j], dp[i - <span class="number">1</span>][j + dw[i]]) ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= Wd[i][<span class="number">0</span>] ; ++ j) dp[i][j] = Inf ; </span><br><span class="line">      <span class="keyword">for</span> (j = Wd[i][<span class="number">1</span>] ; j &lt;= M ; j ++) dp[i][j] = Inf ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) ans = min(ans, dp[N][i]) ; </span><br><span class="line">    <span class="keyword">if</span> (ans &lt; <span class="number">19260817</span>) <span class="keyword">return</span> <span class="built_in">printf</span>(<span class="string">"%d\n%d\n"</span>, <span class="number">1</span>, ans),<span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) S[i] = S[i - <span class="number">1</span>] + S[i] ; l = <span class="number">1</span>, r = N, p ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>, ans = Inf ;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) ans = min(ans, dp[mid][i]) ;</span><br><span class="line">        <span class="keyword">if</span> (ans &lt; <span class="number">19260817</span>) l = mid + <span class="number">1</span>, p = mid ; <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; S[p] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-2001C-统计单词数"><a href="#3-2001C-统计单词数" class="headerlink" title="$3~2001C$ 统计单词数"></a>$3~2001C$ 统计单词数</h1><p><a href="https://www.luogu.org/problem/P1026" target="_blank" rel="noopener">$Link$</a> 一道很水的DP，难点（如果可以称之为难的话）在于判断。然后此处用的是哈希，判断的时候就瞎判就好了（雾</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line">pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; p ; </span><br><span class="line"><span class="keyword">char</span> D[MAXLEN][<span class="number">10</span>] ;</span><br><span class="line"><span class="keyword">const</span> UN LL base = <span class="number">131</span> ;</span><br><span class="line">LL Hash[MAXLEN][MAXLEN], H[<span class="number">10</span>] ;</span><br><span class="line"><span class="built_in">stack</span>&lt; pair &lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; s, s2 ;</span><br><span class="line"><span class="keyword">const</span> UN LL Mod = <span class="number">192183781721L</span>L ;</span><br><span class="line"><span class="keyword">int</span> dp[MAXLEN][<span class="number">50</span>], Len, Length[<span class="number">10</span>], o ;</span><br><span class="line"><span class="keyword">int</span> P, M, K, i, j, k, di, dj ; <span class="keyword">char</span> S[MAXLEN] ;     </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> LL <span class="title">Hashh</span><span class="params">(<span class="keyword">int</span> Mark)</span></span>&#123;</span><br><span class="line">UN LL res = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">if</span> (!Mark) &#123;</span><br><span class="line"><span class="keyword">for</span> (k = j ; k &lt;= i ; ++ k)</span><br><span class="line">res = (res * base + S[k]) % Mod ; </span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= Length[Mark] ; ++k)</span><br><span class="line">res = (res * base + D[Mark][k]) % Mod ;</span><br><span class="line"><span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Sum</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">LL res[<span class="number">7</span>] ;</span><br><span class="line"><span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line"><span class="keyword">for</span> (di = <span class="number">1</span>; di &lt;= M ; ++ di)</span><br><span class="line"><span class="keyword">for</span> (dj = x ; dj &lt;= y - Length[di] ; ++ dj)</span><br><span class="line"><span class="keyword">if</span> (Hash[dj][dj + Length[di]] == H[di]) ++ res[di] ;</span><br><span class="line"><span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line">p = s.top() ;</span><br><span class="line">res[p.first] &gt; res[p.second] ? res[p.second] : res[p.first] = <span class="number">0</span> ; </span><br><span class="line">s.pop(), s2.push(p) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!s2.empty()) s.push(s2.top()), s2.pop() ;</span><br><span class="line"><span class="keyword">return</span> res[<span class="number">1</span>] + res[<span class="number">2</span>] + res[<span class="number">3</span>] + res[<span class="number">4</span>] + res[<span class="number">5</span>] + res[<span class="number">6</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; P &gt;&gt; K ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; P ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%20s"</span>, S + i * <span class="number">20</span>) ;<span class="built_in">cin</span> &gt;&gt; M ; Len = <span class="built_in">strlen</span>(S) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, D[i]), Length[i] = <span class="built_in">strlen</span>(D[i]) - <span class="number">1</span>, H[i] = Hashh(i) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; i ; ++ j)&#123;</span><br><span class="line"><span class="keyword">bool</span> flag = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (di = <span class="number">0</span> ; di &lt;= min(Length[j], Length[i]) ; ++ di)</span><br><span class="line"><span class="keyword">if</span> (D[j][di] != D[i][di])&#123; flag = <span class="number">0</span> ; <span class="keyword">break</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span> (flag) s.push(&#123;i, j&#125;), ++ o ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt;= i ; ++ j) </span><br><span class="line">Hash[j][i] = Hashh(<span class="number">0</span>) ;</span><br><span class="line"><span class="comment">/*for (i = 0 ; i &lt; Len ; ++ i) </span></span><br><span class="line"><span class="comment">for (j = 0 ; j &lt; i ; ++ j) </span></span><br><span class="line"><span class="comment">printf("%d%c", Sum(j, i)," \n"[j == i - 1]) ;*/</span></span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">1</span> ; k &lt;= K ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; Len ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = k - <span class="number">1</span> ; j &lt;= i ; ++ j)</span><br><span class="line">dp[i][k] = max(dp[i][k], dp[max(<span class="number">0</span>, j - <span class="number">1</span>)][k - <span class="number">1</span>] + Sum(j, i)) ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[Len - <span class="number">1</span>][K] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="4-2005B-过河"><a href="#4-2005B-过河" class="headerlink" title="$4~2005B$ 过河"></a>$4~2005B$ 过河</h1><p><a href="https://www.luogu.org/problem/P1052" target="_blank" rel="noopener">$Link$</a></p><p>也是一道很水的DP。整理这个题的原因是因为好久之前的当时做这题时用了一种诡异的做法，即通过对$\sqrt{1e9}$取模进行压缩，但是这显然不对因为1：我的写法没有处理mod之后位置相同的情况；再者转移过程也十分地不服责任：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mod=<span class="number">32501</span>;</span><br><span class="line"><span class="keyword">int</span> f[<span class="number">200000</span>];</span><br><span class="line"><span class="keyword">bool</span> pos[<span class="number">200000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n,l,r,m,cnt=<span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;l&gt;&gt;r&gt;&gt;m;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=m;i++)&#123;</span><br><span class="line"><span class="keyword">int</span> x; <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">pos[x%mod]=<span class="number">1</span>;<span class="keyword">if</span>(l==r&amp;&amp;x%l==<span class="number">0</span>)cnt++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(l==r)&#123;<span class="built_in">cout</span>&lt;&lt;cnt; <span class="keyword">return</span> <span class="number">0</span>;&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mod;i++) f[i]=MAXN;</span><br><span class="line">f[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=mod;i++)</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> j=l;j&lt;=r;j++)&#123;</span><br><span class="line"><span class="keyword">int</span> k=i%mod;</span><br><span class="line"><span class="keyword">if</span>(i&gt;=j)f[i]=min(f[i],f[i-j]+pos[k]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;f[mod];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但问题是，它过了，这就很迷。仔细想想，似乎可能是因为石头数量太小了，只有100，所以随机丢到空间里去期望意义上每$1e7$会有一块石头，且mod之后位于同一个位置的概率的相反数是$32501$，所以很难有这种数据出现……换句话说，数据水死了。</p><p>然而真正的做法应该是“2520缩”，意思就是因为题目中的 s~t 的取值范围是 1~10，所以取$lcm(1,2,..,10)=2520$是可行的。</p><h1 id="5-2009B-Hankson的趣味题"><a href="#5-2009B-Hankson的趣味题" class="headerlink" title="$5~2009B$ Hankson的趣味题"></a>$5~2009B$ Hankson的趣味题</h1><p><a href="https://www.luogu.org/problem/P1072" target="_blank" rel="noopener">$Link$</a></p><p>整这个题只是因为情怀……</p><p>遥不可及的过去啊……<a href="https://pks-loving.blog.luogu.org/solution-p1072" target="_blank" rel="noopener">Solution</a></p><h1 id="6-2004D-虫食算"><a href="#6-2004D-虫食算" class="headerlink" title="$6~2004D$ 虫食算"></a>$6~2004D$ 虫食算</h1><p><a href="https://www.luogu.org/problem/P1092" target="_blank" rel="noopener">$Link$</a></p><p>整这个题更是因为情怀了……</p><p>当时是何时？不记得是末冬还是暑假，只记得我十分开心地去高中部培训，吃早饭之前跟rqy瞎聊，聊什么“是不是只要我发明出可以处理负权边的Dijkstra就可以上清华了”，不自觉地聊到了这道题。嗯…场景什么的都历历在目，尤其是餐厅东边洒落的白色的阳光，一直在我的记忆中闪亮…</p><p>可惜我不是当年那个我了，rqy也不是当年那个rqy了，大家都在迈着自己的步子踏实地前进，终于还是会分道扬镳吧……</p><p>诶诶我在干什么，qaq，学习，学习……</p><p>暴力就是枚举全排列，但显然只有30pts。 于是考虑一个可行性剪枝，其实就是每次dfs刚开始先check一遍合不合法。但是整理这个题的目的也不在于此，而在于其中的<code>pos</code>数组，其实就是用来记录从低位到高位每个未知数的出现顺序的。那么实际上这也是一个优秀的剪枝，因为在dfs里面我们可以根据此对靠近低位的未知数先赋值、先判断（第一个剪枝）。</p><p>所以大概就是可行性剪枝和最优性剪枝相辅相成的结果，比较巧妙。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> _Char ; <span class="keyword">int</span> pos[MAX] ;</span><br><span class="line"><span class="keyword">int</span> Ans[MAX] ; <span class="keyword">bool</span> mark[MAX] ;</span><br><span class="line"><span class="keyword">int</span> N, A[MAX], B[MAX], C[MAX], tot ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i) <span class="built_in">cout</span> &lt;&lt; Ans[i] &lt;&lt; <span class="string">" "</span> ; <span class="built_in">exit</span>(<span class="number">0</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Judge</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> X = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i)&#123;</span><br><span class="line">        <span class="keyword">int</span> NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ;</span><br><span class="line">        <span class="keyword">if</span>((NA + NB + X) % N != NC) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">        X = (NA + NB + X) / N ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">Speed</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Ans[A[<span class="number">0</span>]] + Ans[B[<span class="number">0</span>]] &gt;= N) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i --)&#123;</span><br><span class="line">        <span class="keyword">int</span> NA = Ans[A[i]], NB = Ans[B[i]], NC = Ans[C[i]] ;</span><br><span class="line">        <span class="keyword">if</span> (NA == <span class="number">-1</span> || NB == <span class="number">-1</span> || NC == <span class="number">-1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">        <span class="keyword">if</span> ((NA + NB) % N != NC &amp;&amp; (NA + NB + <span class="number">1</span>) % N != NC) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> sum)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!Speed()) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="keyword">if</span> (sum == N + <span class="number">1</span>)&#123;<span class="keyword">if</span> (Judge()) Print() ; <span class="keyword">return</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i)</span><br><span class="line">        <span class="keyword">if</span>(!mark[i])&#123;</span><br><span class="line">            Ans[pos[sum]] = i, mark[i] = <span class="number">1</span> ;</span><br><span class="line">            dfs(sum + <span class="number">1</span>) ;</span><br><span class="line">            Ans[pos[sum]] = <span class="number">-1</span>, mark[i] = <span class="number">0</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work_pos</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">if</span>(!mark[x])  mark[x] = <span class="number">1</span>,  pos[++ tot] = x ;&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">    fill(Ans, Ans + MAX + <span class="number">2</span>, <span class="number">-1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; A[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; B[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N ; ++ i)&#123; <span class="built_in">cin</span> &gt;&gt; _Char ; C[i] = _Char - <span class="string">'A'</span> ;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; -- i) </span><br><span class="line">      work_pos(A[i]), work_pos(B[i]), work_pos(C[i]) ;</span><br><span class="line">    fill(mark, mark + MAX + <span class="number">2</span>, <span class="number">0</span>) ; dfs(<span class="number">1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-Afterword"><a href="#rm-Afterword" class="headerlink" title="$\rm{Afterword}$"></a>$\rm{Afterword}$</h1><blockquote><p>遥望扬州满地雪，不知已是惊蛰节。</p></blockquote>]]></content>
    
    <summary type="html">
    
      $NOIP2016$以及之前年份$NOIP$中比较水的题目的泛做。
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="NOIP系列" scheme="https://Flower233pks.github.io/blog/tags/NOIP%E7%B3%BB%E5%88%97/"/>
    
      <category term="数学/不等式" scheme="https://Flower233pks.github.io/blog/tags/%E6%95%B0%E5%AD%A6-%E4%B8%8D%E7%AD%89%E5%BC%8F/"/>
    
      <category term="动态规划-背包模型" scheme="https://Flower233pks.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E8%83%8C%E5%8C%85%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="搜索-剪枝" scheme="https://Flower233pks.github.io/blog/tags/%E6%90%9C%E7%B4%A2-%E5%89%AA%E6%9E%9D/"/>
    
      <category term="奇怪的技巧" scheme="https://Flower233pks.github.io/blog/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>Old-NOIP 泛做三</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/11/old-NOIP-0/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/11/old-NOIP-0/</id>
    <published>2019-07-11T10:39:51.000Z</published>
    <updated>2019-07-26T01:44:42.542Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>以下的题是我做了之后不禁感慨“啊，真是个好题”的题们……</p><p>然后首先打出难度标签：<img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p><p><del>然后以下题目按照得较高的部分分的难度排序</del></p><h1 id="1-2013F-华容道"><a href="#1-2013F-华容道" class="headerlink" title="$~1~2013F$ 华容道"></a>$~1~2013F$ 华容道</h1><p><a href="https://www.luogu.org/problem/P1979" target="_blank" rel="noopener">$Link$</a></p><p>可能这道题很难…但是它有70分的暴力分！70分！在loj你甚至可以获得80分！tm这样的话暴力和正解有什么区别吗…从得分的时间分布上来讲，想正解就是大写的不值……</p><p>首先我们思考什么信息是有用的，嗯，空白格子的位子和当前棋子的位置，所以只要我们用BFS（而不是DFS，DFS的状态开销极大，但更可能的是我DFS的打开方式不对吧/sigh）的话，状态数就是$O(n^2m^2)$的，然后总复杂度就是$O(qn^2m^2)$，大概是四亿零500万的运算量上限…然而一开始我算成了四千五百万还纳闷为什么开了<code>-O2</code>在1s以内还跑不出来……</p><p>先贴个暴力吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(vis, <span class="number">0</span>, <span class="keyword">sizeof</span>(vis)) ;</span><br><span class="line">ans = Inf, vis[ex][ey][sx][sy] = <span class="number">1</span> ;</span><br><span class="line">q.push((state)&#123;ex, ey, sx, sy, <span class="number">0</span>, <span class="number">1</span>&#125;) ; </span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">state n = q.front() ; q.pop() ;</span><br><span class="line"><span class="keyword">if</span> (n.sx == tx &amp;&amp; n.sy == ty) ans = min(ans, n.s) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line"><span class="keyword">int</span> kx = n.bx + dx[k], ky = n.by + dy[k], px, py ; </span><br><span class="line"><span class="keyword">if</span> (kx == n.sx &amp;&amp; ky == n.sy) </span><br><span class="line">        px = n.bx, py = n.by ; <span class="keyword">else</span> px = n.sx, py = n.sy ;</span><br><span class="line"><span class="keyword">if</span> (!base[kx][ky] || kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || vis[kx][ky][px][py]) <span class="keyword">continue</span> ;</span><br><span class="line">vis[kx][ky][px][py] = <span class="number">1</span> ;</span><br><span class="line">      q.push((state)&#123;kx, ky, px, py, n.s + <span class="number">1</span>, n.num + <span class="number">1</span>&#125;) ;</span><br><span class="line">&#125; </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (ans &gt;= Inf) <span class="built_in">puts</span>(<span class="string">"-1"</span>) ; <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Q ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i][j]) ;</span><br><span class="line"><span class="keyword">while</span> (Q --) <span class="built_in">cin</span> &gt;&gt; ex &gt;&gt; ey &gt;&gt; sx &gt;&gt; sy &gt;&gt; tx &gt;&gt; ty, bfs() ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>喜闻乐见…不过自己打暴力的能力还是不行啊，还得练啊qaq</p><p>之后就是更加喜闻乐见的状态压缩。我们思考，这$n^2m^2$个状态都他娘的有鸟用吗（李云龙疾呼态），如果空白格子不在目标格子周围，那么无论空白格子怎么移动都不可能用爱发电。所以我们考虑吧直接预处理出来每个<strong>空白格子与目标格子（即起始格子）相邻的状态</strong>之间的代价，之后直接对此跑个$SPFA$就好了，毕竟最坏情况下SPFA的复杂度也只是$O(nM)$的，大概就是$O(n\cdot 4nm)&lt;\frac{O(n^2m^2)}{7.5}$，也算是很稳的复杂度了。</p><p>然后我们思考这样的复杂度是多少。考虑目标格子有$nm$种情况，空白格子在有效情况下只能在其四周，故状态数是$O(4nm)=nm$的。</p><p>然后关于代码实现这块需要比较深入的理解。首先我们先预处理出来当当前格子在随便一个格子上，空白格子想要转到另一个方向的步数。这样就可以抽象成一张空白图上先有的一个一个树（也就是一坨森林）。然后为了让这些森林之间能连上边，再将“空白格子和目标格子换了个位置”这种转移连上边（不连的话就不存在从一个格子到另一个格子的转移了）。同时不要忘了对状态的编号。即：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> _get(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> d)&#123; <span class="keyword">return</span> x * <span class="number">120</span> + y * <span class="number">4</span> + d ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> fx, <span class="keyword">int</span> fy, <span class="keyword">int</span> ox, <span class="keyword">int</span> oy, <span class="keyword">int</span> d)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Id = _get(ox, oy, d) ; </span><br><span class="line">    <span class="built_in">memset</span>(dis, <span class="number">0</span>, <span class="keyword">sizeof</span>(dis)), </span><br><span class="line">    dis[fx][fy] = <span class="number">1</span>, q.push((state)&#123;fx, fy&#125;) ; </span><br><span class="line"><span class="comment">//    cout &lt;&lt; fx &lt;&lt; " " &lt;&lt; fy &lt;&lt; endl ; </span></span><br><span class="line">    <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">        state n = q.front() ; </span><br><span class="line">        <span class="keyword">int</span> nx = n.x, ny = n.y ; q.pop() ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">            <span class="keyword">int</span> kx = nx + dx[k], ky = ny + dy[k] ; </span><br><span class="line">            <span class="keyword">if</span> (kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span>) <span class="keyword">continue</span> ; </span><br><span class="line">            <span class="keyword">if</span> (base[kx][ky] &amp;&amp; !dis[kx][ky] &amp;&amp; (kx != ox || ky != oy)) </span><br><span class="line">                dis[kx][ky] = dis[nx][ny] + <span class="number">1</span>, q.push((state)&#123;kx, ky&#125;) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (d &gt; <span class="number">3</span>) <span class="keyword">return</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> kx = ox + dx[k], ky = oy + dy[k] ; </span><br><span class="line">        <span class="keyword">if</span> (kx &gt; N || ky &gt; M || kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span>) <span class="keyword">continue</span> ; </span><br><span class="line">        <span class="keyword">if</span> (dis[kx][ky] &amp;&amp; (kx != fx || ky != fy) &amp;&amp; base[kx][ky])</span><br><span class="line">            Add(Id, _get(ox, oy, k), dis[kx][ky] - <span class="number">1</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line">    Add(Id, _get(fx, fy, d) ^ <span class="number">1</span>, <span class="number">1</span>) ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以及</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">         <span class="built_in">cin</span> &gt;&gt; base[i][j] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)&#123;</span><br><span class="line">         <span class="keyword">if</span> (!base[i][j]) <span class="keyword">continue</span> ;</span><br><span class="line">         <span class="keyword">if</span> (base[i - <span class="number">1</span>][j]) bfs(i - <span class="number">1</span>, j, i, j, <span class="number">0</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i + <span class="number">1</span>][j]) bfs(i + <span class="number">1</span>, j, i, j, <span class="number">1</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i][j - <span class="number">1</span>]) bfs(i, j - <span class="number">1</span>, i, j, <span class="number">2</span>) ; </span><br><span class="line">         <span class="keyword">if</span> (base[i][j + <span class="number">1</span>]) bfs(i, j + <span class="number">1</span>, i, j, <span class="number">3</span>) ; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后我们考虑在SPFA之前，我们需要求出空白格子从(ex,ey)到(sx, sy)周围需要的步数作为起始点，然后SPFA就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Spfa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; MAXS ; ++ k) f[k] = Inf, vis[k] = <span class="number">0</span> ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">4</span> ; ++ k)&#123;</span><br><span class="line">        <span class="keyword">int</span> Id = _get(sx, sy, k), kx = sx + dx[k], ky = sy + dy[k] ;</span><br><span class="line">        <span class="keyword">if</span> (dis[kx][ky]) f[Id] = dis[kx][ky] - <span class="number">1</span>, Q.push(Id), vis[Id] = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!Q.empty())&#123;</span><br><span class="line">        <span class="keyword">int</span> n = Q.front() ; Q.pop() ; vis[n] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[n] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (f[to(k)] &gt; f[n] + E[k].val)&#123;</span><br><span class="line">                f[to(k)] = f[n] + E[k].val ; </span><br><span class="line">                <span class="keyword">if</span> (!vis[to(k)]) vis[to(k)] = <span class="number">1</span>, Q.push(to(k)) ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-2012C-开车旅行"><a href="#2-2012C-开车旅行" class="headerlink" title="$2~2012C$ 开车旅行"></a>$2~2012C$ 开车旅行</h1><p> <a href="https://www.luogu.org/problem/P1081" target="_blank" rel="noopener">$Link$</a></p><p>不得不说2012的题目质量是真心好啊……</p><p>首先这题为了看上去不是那么毒瘤，于是加了一个70分的暴力分。然而…细节贼多——或者说只是我不细心，比如说把A和B怎么走看反了、算比值的时候用了个假<code>double</code>之类的……</p><p>于是70分好像有个头就会写吧= = 不知道当年什么区分度= =</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Path</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> v1, v2 ;</span><br><span class="line">    <span class="keyword">int</span> Id1, Id2 ;</span><br><span class="line">&#125;P[MAXN] ; <span class="keyword">int</span> i, j ; <span class="keyword">double</span> o, q ;</span><br><span class="line"><span class="keyword">int</span> res, ans, N, M, T, base[MAXN], s[MAXN], x[MAXN], p ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">mabs</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123; <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -x : x ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GO</span><span class="params">(<span class="keyword">int</span> S, <span class="keyword">int</span> H)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> u = <span class="number">0</span> ; res = ans = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (j = S ; j &lt;= N &amp;&amp; j ; u ^= <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span> (u) <span class="keyword">if</span> (res + ans + P[j].v1 &gt; H) <span class="keyword">return</span> ; </span><br><span class="line">       <span class="keyword">else</span> res += P[j].v1, j = P[j].Id1 ;</span><br><span class="line">        <span class="keyword">else</span> <span class="comment">/*pkspks*/</span> <span class="keyword">if</span> (res + ans + P[j].v2 &gt; H) <span class="keyword">return</span> ; </span><br><span class="line">      <span class="keyword">else</span> ans += P[j].v2, j = P[j].Id2 ;</span><br><span class="line">        <span class="comment">//        cout &lt;&lt; j &lt;&lt; endl ;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; q = Inf  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i]) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; M ;  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;s[i], &amp;x[i]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> tp = Inf, w = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="built_in">abs</span>(base[i] - base[j]) ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; tp || (qwq == tp &amp;&amp; base[w] &gt; base[j])) </span><br><span class="line">              tp = qwq, w = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        P[i].Id1 = w, P[i].v1 = tp ; tp = Inf, w = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span> ; j &lt;= N ; ++ j)&#123;</span><br><span class="line">            <span class="keyword">int</span> qwq = <span class="built_in">abs</span>(base[i] - base[j]) ;</span><br><span class="line">            <span class="keyword">if</span> (qwq &lt; tp &amp;&amp; (qwq &gt; P[i].v1 || (qwq == P[i].v1 &amp;&amp; base[P[i].Id1] &lt; base[j])))</span><br><span class="line">                tp = qwq, w = j ;</span><br><span class="line">        &#125;</span><br><span class="line">        P[i].Id2 = w, P[i].v2 = tp ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//    GO(2, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//    GO(4, T), cout &lt;&lt; ans &lt;&lt; " " &lt;&lt; res &lt;&lt; endl ;</span></span><br><span class="line">    <span class="comment">//    for (i = 1 ; i &lt;= N ; ++ i) cout &lt;&lt; i &lt;&lt; " " &lt;&lt; P[i].v1 &lt;&lt; " " &lt;&lt; P[i].Id1 &lt;&lt; " " &lt;&lt; P[i].v2 &lt;&lt; " " &lt;&lt; P[i].Id2 &lt;&lt; endl ;</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123; </span><br><span class="line">      GO(i, T) ; o = <span class="number">1.0</span> * res ? (<span class="number">1.0</span> * ans) / (<span class="number">1.0</span> * res) : Inf ; </span><br><span class="line">      <span class="keyword">if</span> (o &lt; q ||(o == q &amp;&amp; base[p] &lt; base[i])) q = o, p = i ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      GO(s[i], x[i]), <span class="built_in">printf</span>(<span class="string">"%lld %lld\n"</span>, ans, res) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后感觉从暴力到正解完全不是一个难度的。首先考虑到底是什么地方阻碍了社会的发展——初始化似乎是$n^2$的，走似乎是$&lt;n^2$的，那么从初始化入手：</p><h2 id="rm-Part-1-初始化的优化"><a href="#rm-Part-1-初始化的优化" class="headerlink" title="$\rm{Part~1}$ 初始化的优化"></a>$\rm{Part~1}$ 初始化的优化</h2><p>我们思考如果当前轮到第$i$高的城市了，并且此时所有现存城市中不存在编号在$i$之前的城市，即$i$是最左边的城市，那么对其有用的信息只会在第$i-1,i-2,i+1$或者第$i+2$的城市中选取。这就提示我们似乎如果从值域上考虑就是$O(4n)$的了——只要我们保证不存在在$i$左边的城市、即对应城市不可走的情况。</p><p>然后这个时候有个很神仙的想法就是<strong>双向链表优化</strong>，我们考虑按高度排完序之后，对相邻元素建立双向链表。然后<strong>按照从左到右的顺序枚举城市、get信息然后删除掉这个城市</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(BASE A, BASE B)</span></span>&#123; <span class="keyword">return</span> A.h &lt; B.h ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(BASE A, BASE B)</span></span>&#123; <span class="keyword">return</span> A.id &lt; B.id ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">inlaw</span><span class="params">(<span class="keyword">int</span> pos)</span></span>&#123; <span class="keyword">return</span> (pos &gt; N || !pos) ? Inf : <span class="number">0</span> ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">signed</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; q = Inf  ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) pre[i] = i - <span class="number">1</span>, nxt[i] = i + <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld"</span>, &amp;base[i].h), base[i].id = i ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; T &gt;&gt; M ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lld%lld"</span>, &amp;s[i], &amp;x[i]) ;</span><br><span class="line">    sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, cmp) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Tid[base[i].id] = i ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">int</span> t = Tid[i] ;</span><br><span class="line">        d[<span class="number">1</span>].h = inlaw(pre[t]) + <span class="built_in">abs</span>(base[pre[t]].h - base[t].h),</span><br><span class="line">        d[<span class="number">2</span>].h = inlaw(pre[pre[t]]) + <span class="built_in">abs</span>(base[pre[pre[t]]].h - base[t].h) ;</span><br><span class="line">        d[<span class="number">3</span>].h = inlaw(nxt[t]) + <span class="built_in">abs</span>(base[nxt[t]].h - base[t].h), </span><br><span class="line">        d[<span class="number">4</span>].h = inlaw(nxt[nxt[t]]) + <span class="built_in">abs</span>(base[nxt[nxt[t]]].h - base[t].h) ;</span><br><span class="line">        d[<span class="number">1</span>].id = base[pre[t]].id, d[<span class="number">2</span>].id = base[pre[pre[t]]].id, </span><br><span class="line">        d[<span class="number">3</span>].id = base[nxt[t]].id, d[<span class="number">4</span>].id = base[nxt[nxt[t]]].id, </span><br><span class="line">        sort(d + <span class="number">1</span>, d + <span class="number">5</span>, cmp) ;</span><br><span class="line">        P[i].Id1 = d[<span class="number">1</span>].id, P[i].v1 = d[<span class="number">1</span>].h, </span><br><span class="line">        P[i].Id2 = d[<span class="number">2</span>].id, P[i].v2 = d[<span class="number">2</span>].h ; </span><br><span class="line">        pre[nxt[t]] = pre[t], nxt[pre[t]] = nxt[t] ;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后初始化的工作就优化完了。至此可以在<code>Luogu</code>获得75pts的好成绩。</p><h2 id="rm-Part-2-走的优化"><a href="#rm-Part-2-走的优化" class="headerlink" title="$\rm{Part~2}$ 走的优化"></a>$\rm{Part~2}$ 走的优化</h2><p>…然而只有第一个优化情况并不会好转多少。查看数据之后发现原来最后几个点的$s$和$x$都完全是随的那种……所以就复杂度爆炸。然后我们考虑这么一个喜闻乐见的事情——限制似乎只有“小于x”和“可以继续走”诶，于是似乎相邻的几步如果都不超过限制是不是就可以一起走？于是想到<strong>倍增预处理</strong>。</p><p>我们用$A_{i,j}$表示从i号点开始，走$2^j$<strong>轮</strong>之后$A$走过的路程；同理$B_{i,j}$表示从i号点开始，走$2^j$<strong>轮</strong>之后$B$走过的路程。并且选择用$f_{i,j}$表示从i开始走$2^j$轮之后到达的点。然后值得注意的是最后可能走的不满一整轮，于是特判一下A能不能再走一次就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sort(base + <span class="number">1</span>, base + N + <span class="number">1</span>, cmp2) ;<span class="comment">//重排回来= =</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line">    f[i][<span class="number">0</span>] = P[P[i].Id2].Id1 ;</span><br><span class="line">    <span class="keyword">if</span> (P[i].Id2) </span><br><span class="line">        A[i][<span class="number">0</span>] = <span class="built_in">abs</span>(base[P[i].Id2].h - base[i].h) ; </span><br><span class="line">  <span class="keyword">if</span> (P[P[i].Id2].Id1)</span><br><span class="line">        B[i][<span class="number">0</span>] = <span class="built_in">abs</span>(base[P[i].Id2].h - base[P[P[i].Id2].Id1].h) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">f[j][i] = f[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>], </span><br><span class="line">A[j][i] = A[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] + A[j][i - <span class="number">1</span>], </span><br><span class="line">B[j][i] = B[f[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] + B[j][i - <span class="number">1</span>] ;</span><br><span class="line">...</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">GO</span><span class="params">(<span class="keyword">int</span> S, ll H)</span></span>&#123;</span><br><span class="line">ans = res = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) </span><br><span class="line"><span class="keyword">if</span> (f[S][j] &amp;&amp; A[S][j] + B[S][j] &lt;= H) </span><br><span class="line">ans += A[S][j], res += B[S][j], H -= (A[S][j] + B[S][j]), S = f[S][j] ;</span><br><span class="line"><span class="keyword">if</span> (A[S][<span class="number">0</span>] &lt;= H) ans += A[S][<span class="number">0</span>] ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-2016B-天天爱跑步"><a href="#3-2016B-天天爱跑步" class="headerlink" title="$3~2016B$ 天天爱跑步"></a>$3~2016B$ 天天爱跑步</h1><p><a href="https://www.luogu.org/problem/P1600" target="_blank" rel="noopener">$Link$</a></p><p>……当年的毒瘤题，还记得那还是我第一次参加NOIP（普及组），不出所料地考挂，然后rqy不出所料地考好……</p><p>咳，偏题了，然后对于这道题，我索性把每个部分分都写了一遍：</p><h2 id="rm-Part-1-25pts"><a href="#rm-Part-1-25pts" class="headerlink" title="$\rm{Part~1}$ 25pts"></a>$\rm{Part~1}$ 25pts</h2><p>$n,m\leq 1000$</p><p>其实就是LCA一下然后$nm$的统计答案就完了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">fa[now][<span class="number">0</span>] = f, dep[now] = dep[f] + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; <span class="keyword">else</span> build(to(k), now) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">h = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= h ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ;</span><br><span class="line"><span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ; <span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; <span class="keyword">return</span> fa[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;x, &amp;y), Add(x, y) ;</span><br><span class="line">build(<span class="number">1</span>, <span class="number">0</span>), Setup() ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s[i], &amp;e[i]), </span><br><span class="line">  lca1[i] = t = lca(s[i], e[i]), </span><br><span class="line">  _up[i] = -(dep[t] &lt;&lt; <span class="number">1</span>) + (dep[s[i]] + dep[e[i]]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i, <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans), ans = <span class="number">0</span>)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j) t = lca(e[j], i), p = lca(s[j], i), </span><br><span class="line">  w1 = -(dep[p] &lt;&lt; <span class="number">1</span>) + (dep[i] + dep[s[j]]), </span><br><span class="line">  w2 = dep[i]  +  dep[e[j]] -  (dep[t] &lt;&lt; <span class="number">1</span>), </span><br><span class="line">    ans += (w1 == base[i]) * (_up[j] == w1 + w2) ;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Part-2-15pts"><a href="#rm-Part-2-15pts" class="headerlink" title="$\rm{Part~2}$ 15pts"></a>$\rm{Part~2}$ 15pts</h2><p>这部分是链，保证$i$到$i+1$有一条边。</p><p>那么其实这个问题就转化成了在一个序列上，与点$i$相隔恰好为$t[i]$的点的个数，顺便注意判断一下走没走完就好。但是这个地方我用了一个肥肠zz的写法，就是每次加完之后删除到这个点停止的那些点，而“那些点”的求法则是我手写了一个很诡异的二分……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Tink&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Nodes</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> s, e, n ;</span><br><span class="line">&#125;u[MAXN], v[MAXN] ; <span class="keyword">int</span> t1, t2 ;</span><br><span class="line"><span class="keyword">int</span> be[MAXN], bs[MAXN], res[MAXN], k1 = <span class="number">0</span>, k2 = <span class="number">0</span> ;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp1</span><span class="params">(Nodes a, Nodes b)</span> </span>&#123; <span class="keyword">return</span> a.e &lt; b.e ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmp2</span><span class="params">(Nodes a, Nodes b)</span> </span>&#123; <span class="keyword">return</span> a.e &gt; b.e ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> p, <span class="keyword">bool</span> m)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>, r = (m ? k2 : k1) + <span class="number">1</span> , mid, l0, l1 ; </span><br><span class="line"><span class="keyword">if</span> (!m)&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (u[mid].e &lt; p) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">&#125; l0 = l, l = <span class="number">1</span>, r = k1 + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (u[mid].e &lt; p + <span class="number">1</span>) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">&#125; l1 = l ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l0 ; i &lt; l1 ; ++ i) bs[u[i].s] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (v[mid].e &lt; p) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">&#125; l0 = l, l = <span class="number">0</span>, r = k2 + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (v[mid].e &lt; p + <span class="number">1</span>) l = mid + <span class="number">1</span> ; <span class="keyword">else</span> r = mid ;</span><br><span class="line">&#125; l1 = l ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = l0 ; i &lt; l1 ; ++ i) be[v[i].s] -- ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) &#123;</span><br><span class="line">t1 = qr(), t2 = qr() ; </span><br><span class="line"><span class="keyword">if</span> (t1 &lt; t2) bs[t1] ++, u[++ k1] = (Nodes)&#123;t1, t2, k1&#125; ;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">/**/</span>be[t1] ++, v[++ k2] = (Nodes)&#123;t1, t2, k2&#125; ;</span><br><span class="line">&#125;</span><br><span class="line">sort(u + <span class="number">1</span>, u + k1 + <span class="number">1</span>, cmp1) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) res[i] += bs[i - base[i]], del(i, <span class="number">0</span>) ;</span><br><span class="line">sort(v + <span class="number">1</span>, v + k2 + <span class="number">1</span>, cmp1) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N ; i &gt;= <span class="number">1</span> ; -- i) res[i] += be[i + base[i]], del(i, <span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="built_in">cout</span> &lt;&lt; res[p] &lt;&lt; <span class="string">" "</span> ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Part-3-20pts"><a href="#rm-Part-3-20pts" class="headerlink" title="$\rm{Part~3}$ 20pts"></a>$\rm{Part~3}$ 20pts</h2><p>保证所有起点都在根（1号点）。</p><p>其实这个部分也是挺水的。就是考虑一个树形DP即可。然后判断也很好判断，如果这个点的开眼时间正好是根到它的距离（深度差），那么就会一定会满足到它的点和到它的子树内的所有的点。否则就肯定不行，也就是一个都不满足。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> DP&#123;</span><br><span class="line">    <span class="keyword">int</span> dp[MAXN], dis[MAXN] ;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">            <span class="keyword">if</span> (to(k) == fa) <span class="keyword">continue</span> ;</span><br><span class="line">            dis[to(k)] = dis[now] + <span class="number">1</span>, sum += dfs(to(k), now) ; </span><br><span class="line"> &#125;</span><br><span class="line"> dp[now] += sum ; <span class="keyword">return</span> dp[now] ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve3</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">memset</span>(dis, <span class="number">63</span>, <span class="keyword">sizeof</span>(dis)), dis[<span class="number">1</span>] = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) dp[e[i]] ++ ; dp[<span class="number">1</span>] = dfs(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line">          <span class="keyword">if</span> (base[i] == dis[i]) <span class="built_in">printf</span>(<span class="string">"%d "</span>, dp[i]) ; <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="number">0</span> &lt;&lt; <span class="string">" "</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是现在就有了60pts的优秀分数。似乎这样的话就可以直接把剩下的部分弃了去写T3的期望DP辽233</p><h2 id="rm-Part-4-and-5-40pts"><a href="#rm-Part-4-and-5-40pts" class="headerlink" title="$\rm{Part~4~and~5}$  40pts"></a>$\rm{Part~4~and~5}$  40pts</h2><p>剩下的部分没有选择分开写<del>所以就不算谢了每个部分分是不是</del>，因为剩下的两个部分实在是太像了，都要用到一种思想——<strong>桶</strong>. <del>其实80pts还有一种不是很想写的写法在这里就留个图吧：</del></p><p><img src="1.png" alt></p><p>然后我们思考桶的解法。我们把每一段路程拆成向上和向下两段。下文中设$x$为当前节点。</p><ul><li><p>对于向上的路径</p><ul><li>首先可以产生贡献的点就是子树内的$buc[dep[x]+ base[x]]$，这个我们用作差来求解（原因是我们可能会遍历许多棵子树所以会产生数值相同但不合法的贡献）。</li><li>其次我们需要知道，如果一个人的起点和终点的LCA在子树内但不是$x$，那么也不会产生贡献。解决方案是每次dfs完一个点向上回溯的时候删除掉子树内所有以该点为LCA的点。</li><li>同时也需要我们更新以该节点为起点的路径的桶。</li></ul></li><li><p>对于向下的路径</p><ul><li>首先对于一条路径$(u,v)$，当对点i产生贡献时可以推出来式子：</li></ul><p>$$<br>dep_v-dis_{u,v}=dep_i-base_i<br>$$</p><pre><code>那么也就是说我们可以通过把每条路径的$dep_v-dis_{u,v}$压到桶里面，然后每次计算贡献。</code></pre><ul><li>同时我们还是需要消除贡献，即消除那些对于儿子而言在父亲那里停止的路径，方法就是在向下迭代之前先把所有以当前点为终点的贡献加上，到儿子时通过作差就可以减去这部分。注意向上回溯时还是需要删除那些蜷缩在子树内的路径。</li></ul></li></ul><p>之后还有需要注意的，就是如果在一条路径的LCA处正好可以观察到这条路径，那么就需要<code>-1</code>，因为我们上升下降统计了两遍。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> Prepare&#123; <span class="comment">//25</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;a, <span class="keyword">const</span> <span class="keyword">int</span> &amp;b)</span> </span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f, dep[now] = dep[f] + <span class="number">1</span>, H = max(H, dep[now]) ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; <span class="keyword">else</span> build(to(k), now) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Setup</span><span class="params">()</span></span>&#123;</span><br><span class="line">    h = <span class="built_in">log</span>(N) / <span class="built_in">log</span>(<span class="number">2</span>) + <span class="number">1</span> ; </span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= h ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            fa[i][j] = fa[fa[i][j - <span class="number">1</span>]][j - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lca</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (dep[u] &lt; dep[v]) u ^= v ^= u ^= v ; l = dep[u] - dep[v] ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (dep[fa[u][k]] &gt;= dep[v]) u = fa[u][k] ;</span><br><span class="line">   <span class="keyword">if</span> (u == v) <span class="keyword">return</span> u ; <span class="keyword">for</span> (<span class="keyword">int</span> k = h ; k &gt;= <span class="number">0</span> ; -- k) <span class="keyword">if</span> (fa[u][k] != fa[v][k]) u = fa[u][k], v = fa[v][k] ; <span class="keyword">return</span> fa[u][<span class="number">0</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">wo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; <span class="keyword">return</span> -(dep[c] &lt;&lt; <span class="number">1</span>) + (dep[a] + dep[b]) ; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> pks&#123;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Prepare ;</span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; v1[MAXN], v2[MAXN], v3[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> buc_d[MAXN &lt;&lt; <span class="number">2</span>], buc_u[MAXN &lt;&lt; <span class="number">2</span>], ans[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs1</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> co = base[now] + dep[now], ks ; <span class="keyword">if</span> (co &lt;= H) ks = buc_d[co] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next) <span class="keyword">if</span> (fa ^ to(k)) dfs1(to(k), now) ;</span><br><span class="line">buc_d[dep[now]] += cnbt[now] ; <span class="keyword">if</span> (co &lt;= H) ans[now] = buc_d[co] - ks ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v1[now].size() ; ++ k) -- buc_d[dep[v1[now][k]]] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs2</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> fa)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> co = dep[now] - base[now] + N, ks = buc_u[co] ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v2[now].size() ; ++ k) ++ buc_u[v2[now][k] + N] ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next) <span class="keyword">if</span> (fa ^ to(k)) dfs2(to(k), now) ;</span><br><span class="line">ans[now] += buc_u[co] - ks ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; v3[now].size() ; ++ k) -- buc_u[v3[now][k] + N] ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve5</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      cnbt[s[i]] ++, v1[LCA[i]].push_back(s[i]) ; dfs1(<span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      v2[e[i]].push_back(dep[e[i]] - _up[i]), </span><br><span class="line">    v3[LCA[i]].push_back(dep[e[i]] - _up[i]) ;  dfs2(<span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      <span class="keyword">if</span> (dep[s[i]] - dep[LCA[i]] == base[LCA[i]]) -- ans[LCA[i]] ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, ans[i]) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> Prepare ; <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) x = qr(), y = qr(), Add(x, y) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;s[i], &amp;e[i]) ;</span><br><span class="line">    build(<span class="number">1</span>, <span class="number">0</span>), Setup() ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) </span><br><span class="line">      LCA[i] = lca(s[i], e[i]), _up[i] = wo(s[i], e[i], LCA[i]) ; </span><br><span class="line">    pks :: Solve5() ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，然后这道题就完了。不得不说虽然当时用心做了，但是过上几周再反过头来看还是觉得有些细节理解的并不到位、或者说是满分做法中的有些流程当时根本没有仔细推导。</p><p>不过不得不说这个题还是非常妙的。或许有时候题面复杂、需求复杂会让人忘记这道题到底有多巧妙…反正就是感觉这道题用“桶+即时修改”这个组合思想还是很<code>nice</code>的。</p><h1 id="4-2012F-疫情控制"><a href="#4-2012F-疫情控制" class="headerlink" title="$4~2012F$ 疫情控制"></a>$4~2012F$ 疫情控制</h1><p><a href="https://www.luogu.org/problem/P1084" target="_blank" rel="noopener">$Link$</a></p><p>…这个题之所以放在最后一个是因为我真的不知道部分分该怎么写啊。</p><p>嗯，首先是二分，这倒是可以想到。之后一开始想的是似乎不断把城市向上移动就好了，毕竟越靠上越优；但是样例就把我这种写法卡掉了，原因很浅显，我忽略了绕过根继续走的那些点可以继续产生贡献……于是就很GG。</p><p>…于是我选择统计了那些可以跨越根的节点。对于最终每个被覆盖的节点，我用的是直接更新<code>vector</code>预处理出来挂在每个点底下的叶子节点，check的时候直接判一下每个节点的mark。然而这样写的很繁琐，并且复杂度也是个迷…最后只能不了了之了</p><p>所以大概这个题我想出了50%~60%？…然而还是没有分数。</p><h2 id="rm-Part-1-倍增！倍增！倍增！"><a href="#rm-Part-1-倍增！倍增！倍增！" class="headerlink" title="$\rm{Part~1}$ 倍增！倍增！倍增！"></a>$\rm{Part~1}$ 倍增！倍增！倍增！</h2><p>首先喜闻乐见的是，我们向上跳的时候van♂全可以用倍增来搞，只要预处理出$2^k$级祖先就好了。</p><p>然后注意顺便判断一下可不可以拐弯，即跳到根之后是否在二分的时间内可以继续向下跳。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; Army[MAXN], Pest[MAXN] ;</span><br><span class="line"><span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line"><span class="built_in">memset</span>(Army, <span class="number">0</span>, <span class="keyword">sizeof</span>(Army)) ;</span><br><span class="line"><span class="built_in">memset</span>(Pest, <span class="number">0</span>, <span class="keyword">sizeof</span>(Pest)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    t = base[i] ;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">        <span class="keyword">if</span> (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) <span class="keyword">continue</span> ; </span><br><span class="line">  <span class="keyword">else</span> t = fa[t][j] ;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) res[t] = <span class="number">1</span> ; </span><br><span class="line">  <span class="keyword">else</span> &#123; </span><br><span class="line">          t = base[i] ; </span><br><span class="line">          <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) </span><br><span class="line">              <span class="keyword">if</span> (fa[t][j] &gt; <span class="number">1</span>) t = fa[t][j] ; </span><br><span class="line">          Army[++ n] = mp(x - Sum[base[i]], t) ; </span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Part-2-转化！转化！转化！"><a href="#rm-Part-2-转化！转化！转化！" class="headerlink" title="$\rm{Part~2}$ 转化！转化！转化！"></a>$\rm{Part~2}$ 转化！转化！转化！</h2><p>这个地方有个肥肠有意思的点，就是我们思考假设一个叶子节点没有被覆盖，那么就说明一定存在它的某一级祖先的整棵子树没有被覆盖。那么这就提示我们可以考虑<strong>直接判断根的每个儿子是否都被覆盖了（树形结构的优越性）</strong> </p><p>嗯，于是对于我们上一部分打完mark之后的那些点（暂时是只有不会拐弯的被打了mark），我们直接考虑不进行一次$O(n)$的<code>dfs</code>就可以完成<code>push_up</code>的操作。</p><p>然后我们考虑如何操作那些可以拐弯的点。思考最优的方案一定是越高越好，所以不妨就让他拐过来之后落在根的儿子上。于是我们需要统计这个的代价，并对收集来的两个信息分别排序。之后就直接双指针扫一遍根的全部儿子，看看是否全部都被覆盖了即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> x = <span class="number">1</span>, y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa[rt][<span class="number">0</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">        push_down(to(k)) ; x &amp;= res[to(k)] ; y = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">1</span> &amp;&amp; x &amp;&amp; y) res[rt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line">push_down(<span class="number">1</span>) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>] ; k ; k = E[k].next) </span><br><span class="line">  <span class="keyword">if</span> (res[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> Pest[++ m] = mp(E[k].v, to(k)) ;</span><br><span class="line">j = <span class="number">1</span> ; sort(Army + <span class="number">1</span>, Army + n + <span class="number">1</span>, cmp), sort(Pest + <span class="number">1</span>, Pest + m + <span class="number">1</span>, cmp) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">if</span> (!res[Army[i].sc]) res[Army[i].sc] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> j &gt; m ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，贴个总程序吧：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> to, next, v ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt, head[MAXN], n, m ; <span class="keyword">bool</span> res[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> N, M, P, Sum[MAXN], ans, base[MAXN], fa[MAXN][<span class="number">25</span>], i, j, l, r, mid ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)</span></span>&#123;</span><br><span class="line">    P += w ;</span><br><span class="line">    E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">    E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fr first</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> sc second</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mp(a, b) make_pair(a, b)</span></span><br><span class="line">pair&lt;<span class="keyword">int</span> ,<span class="keyword">int</span>&gt; Army[MAXN], Pest[MAXN] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; a, pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; b)</span></span>&#123; <span class="keyword">return</span> a.fr &lt; b.fr ; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">20</span> ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j)</span><br><span class="line">            fa[j][i] = fa[fa[j][i - <span class="number">1</span>]][i - <span class="number">1</span>] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">    fa[now][<span class="number">0</span>] = f ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line">        Sum[to(k)] = Sum[now] + E[k].v ; dfs(to(k), now) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> x = <span class="number">1</span>, y = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = head[rt] ; k ; k = E[k].next)&#123;</span><br><span class="line">        <span class="keyword">if</span> (to(k) == fa[rt][<span class="number">0</span>]) <span class="keyword">continue</span> ;</span><br><span class="line">        push_down(to(k)) ; x &amp;= res[to(k)] ; y = <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rt &gt; <span class="number">1</span> &amp;&amp; x &amp;&amp; y) res[rt] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t ; n = m = <span class="number">0</span> ;</span><br><span class="line">    <span class="built_in">memset</span>(res, <span class="number">0</span>, <span class="keyword">sizeof</span>(res)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Army, <span class="number">0</span>, <span class="keyword">sizeof</span>(Army)) ;</span><br><span class="line">    <span class="built_in">memset</span>(Pest, <span class="number">0</span>, <span class="keyword">sizeof</span>(Pest)) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        t = base[i] ;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j)</span><br><span class="line">            <span class="keyword">if</span> (!fa[t][j] || Sum[base[i]] - Sum[fa[t][j]] &gt; x) <span class="keyword">continue</span> ; <span class="keyword">else</span> t = fa[t][j] ;</span><br><span class="line">        <span class="keyword">if</span> (t &gt; <span class="number">1</span>) res[t] = <span class="number">1</span> ; <span class="keyword">else</span> &#123; t = base[i] ; <span class="keyword">for</span> (j = <span class="number">20</span> ; j &gt;= <span class="number">0</span> ; -- j) <span class="keyword">if</span> (fa[t][j] &gt; <span class="number">1</span>) t = fa[t][j] ; Army[++ n] = mp(x - Sum[base[i]], t) ; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    push_down(<span class="number">1</span>) ; <span class="keyword">for</span> (<span class="keyword">int</span> k = head[<span class="number">1</span>] ; k ; k = E[k].next) <span class="keyword">if</span> (res[to(k)]) <span class="keyword">continue</span> ; <span class="keyword">else</span> Pest[++ m] = mp(E[k].v, to(k)) ;</span><br><span class="line">    j = <span class="number">1</span> ; sort(Army + <span class="number">1</span>, Army + n + <span class="number">1</span>, cmp), sort(Pest + <span class="number">1</span>, Pest + m + <span class="number">1</span>, cmp) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= n ; ++ i)&#123;</span><br><span class="line">        <span class="keyword">if</span> (!res[Army[i].sc]) res[Army[i].sc] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Army[i].fr &gt;= Pest[j].fr) res[Pest[j].sc] = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (res[Pest[j].sc] &amp;&amp; j &lt;= m) ++ j ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> j &gt; m ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N ; <span class="keyword">int</span> a, b, c ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), Add(a, b, c) ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; M ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ; dfs(<span class="number">1</span>, <span class="number">0</span>) ; Init() ;</span><br><span class="line">    l = <span class="number">0</span>, r = P ;</span><br><span class="line">    <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">if</span> (check(mid)) r = mid - <span class="number">1</span>, ans = mid ; <span class="keyword">else</span> l = mid + <span class="number">1</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-Afterword"><a href="#rm-Afterword" class="headerlink" title="$\rm{Afterword}$"></a>$\rm{Afterword}$</h1><p>其实总感觉自己做这些题还是有些力不从心233</p><p>不得不说类似于“二分答案”这种东西是很有OI风味的，毕竟是一种特殊的思想…不知道自己什么时候能把类似的所有思想真正地打包学会啊qaq</p>]]></content>
    
    <summary type="html">
    
      $NOIP2016$以及之前年份$NOIP$中优秀题目的泛做。
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Luogu" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Luogu/"/>
    
    
      <category term="树模型" scheme="https://Flower233pks.github.io/blog/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="搜索-剪枝" scheme="https://Flower233pks.github.io/blog/tags/%E6%90%9C%E7%B4%A2-%E5%89%AA%E6%9E%9D/"/>
    
      <category term="奇怪的技巧" scheme="https://Flower233pks.github.io/blog/tags/%E5%A5%87%E6%80%AA%E7%9A%84%E6%8A%80%E5%B7%A7/"/>
    
      <category term="贪心" scheme="https://Flower233pks.github.io/blog/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="倍增" scheme="https://Flower233pks.github.io/blog/tags/%E5%80%8D%E5%A2%9E/"/>
    
  </entry>
  
  <entry>
    <title>NOIP2017泛做</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/11/NOIP2017/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/11/NOIP2017/</id>
    <published>2019-07-11T10:30:58.000Z</published>
    <updated>2019-07-25T03:36:41.125Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Omega"><a href="#Omega" class="headerlink" title="$\Omega$"></a>$\Omega$</h1><p>嗯，这个代表“前言”的字母很帅。</p><p>先来总结一下每个题的难度，A题<code>提高（证明）/普及-（找规律）</code>, B题<code>提高</code>， C题<code>提高+</code>，总结来看，Day1比较送；D题<code>普及+</code>，E题<code>省选-</code>，F题<code>省选-</code>，Day2不如Day1水。</p><p>PS: <code>提高</code>以NOIP提高组平均难度为准，<code>省选</code>以弱省省选为准（比如以<code>SNOI2019</code>平均难度作为基准线）</p><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><p>·由于当时场上切了这道题，导致我对“找规律“这种投机取巧的做题方式情有独钟，从而在某些计数题时不好好想DP反而猜sb规律……感觉很GG……</p><p>其实这个题就是给一个方程：<br>$$<br>ax+by \not= t \quad x,y, \in\mathbb{N},\quad t\in \mathbb{N+} \quad (a,b)= 1<br>$$<br>求$\max{t}$</p><p>呃，首先，我想了一种很zz的证明方式：</p><ul><li><p>当$t = a \cdot b - a - b$时，$t$满足这个方程</p><ul><li><p>我们通过移项可以得到：</p></li><li><p>$$<br>ax+by-ab+a+b=0 \\\<br>a(x-b +1) + b(y+1) = 0 \\\<br>$$</p></li><li><p>观察这个式子，要么有$y+1=0$且$x-b+1=0$，要么有$a(b-x-1) = b(y+1)\cdots(1)$ . 第一种情况显然不成立，那么我们考虑第二种情况。此时因为$(a,b)=1$，所以会有$b~|~(b-x-1) \to b ~|~(x+1)$, 同理$a~|~(y+1)$ .但同时我们将$(1)$式搞一搞就可以得到$$\frac{a}{b} = \frac{b-(x+1)}{y+1}$$. 但因为$a,b \in \mathbb{N+}$，所以会有$b&gt;(x+1)$ ; 因为$b~|~(x+1)$，有$b\leq x+1$或$x+1=0$（舍） ，矛盾，故此时$t$满足这个方程。</p></li></ul></li><li><p>当$t&gt;a\cdot b-a-b$时，$t$总不满足。</p><ul><li>不妨设$t_0=a\cdot b-a-b, ~t=t_0+k, ~k\in\mathbb{N+}$</li><li>此时……然后就不会了2333——以下是借鉴的<a href="https://www.cnblogs.com/xxzh/p/9178564.html" target="_blank" rel="noopener">星星之火OIer</a>巨佬的思路：</li></ul></li><li><p>对于任意正整数$k\geq ab−a−b+1$，即$k+a+b\geq ab+1$</p><ul><li>设$k+a+b = \mu a+m~~(k\geq b,1\leq m &lt;a)$. 同时：<br>$$<br>\because (a,b)=1\\\<br>\therefore \exists x_0,y_0 \in \mathbb{Z} \quad s.t. \quad ax_0+by_0=1 \\\<br>\therefore \exists x_1,y_1∈\mathbb{Z}，−(b−1)\leq x_1\leq 0 \quad s.t.\quad  ax_1+by_1=m\\\<br>$$<br>这里的意思其实是设$−(b−1)\leq x_1\leq 0$，一定存在整数$y_1$使得$ax_1+by+_1=m$成立。原因就是在整数$x_1$的取值中一共有$b$个数，$y_1=(m−ax_1)/b$，根据鸽笼原理之类的zz定理，我们总是可以找到$x_1$使得$m−ax_1$能被$b$整除。</li></ul><p>显然，$y_1\geq 1(ax_1\leq 0,m &gt;0, b&gt;0, 因此y_1\geq 1,)$</p><p>于是，取$x=\mu+x_1−1,y=y_1−1$</p><p>注意到$x_1,y_1$的取值范围，得$x,y\geq 0$， 即有$ax+by=k$</p></li></ul><hr><p>？？？不知不觉写了小半个下午？？看起来A题确实是结论题了（sigh</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> <span class="keyword">long</span>  A, B ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; A &gt;&gt; B ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; A * B - A - B ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><p> ……像这种题不就是看脸题吗…手一抖就调不出来了$\rm{qaq}$</p><p>题解以前写过，于是直接把主要部分引用过来（以前的码风还真是抽搐</p><blockquote><p><strong>读入</strong>：</p><p>我们先用$while$按字符读入每个程序的第一行，抠出需要检验的复杂度，$O(1)$用$0$来存$[n^0=1  $ $~~~$ $ (n!=0)]$.</p><p>注意，有可能有两位数，需要多扣一位……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&gt;  <span class="keyword">while</span>(o!=<span class="string">')'</span>)&#123;</span><br><span class="line">&gt;    <span class="keyword">if</span>(o==<span class="string">'1'</span>&amp;&amp;!chk) </span><br><span class="line">&gt;   need_check=<span class="number">0</span>;</span><br><span class="line">&gt;    <span class="keyword">if</span>(o==<span class="string">'n'</span>)&#123;</span><br><span class="line">&gt;       <span class="built_in">cin</span>&gt;&gt;o&gt;&gt;o;</span><br><span class="line">&gt;          need_check=o<span class="number">-48</span>;</span><br><span class="line">&gt;   chk=<span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;       o=getchar();</span><br><span class="line">&gt;       <span class="keyword">if</span>(<span class="built_in">isdigit</span>(o)&amp;&amp;chk)need_check*=<span class="number">10</span>,need_check+=(o<span class="number">-48</span>); </span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  getchar();</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>至于最后为什么要再$gatchar()$一次……自己试试就知道了。</p><p>那么接下来就要按行读入循环了，比较简单。</p><p><strong>初始化</strong>：</p><p>为了使码风简洁，所以写到函数里了。这个地方我用到了三个栈，一个用来记录每个循环的答案（因为有可能有多个相互独立的循环），一个用来记录每次$F$时读入的循环上下界。以上两个都是$int$栈,还有一个$char$栈，存储每次定义的循环变量，而这个字符栈搭配一个$bool$性的数组，用于记录是否可用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="meta">#<span class="meta-keyword">define</span> MAX 1000000</span></span><br><span class="line">&gt;<span class="keyword">int</span> i,x,y,t,tt,num,cntf,cnte,res,ans[MAX],T,l,now,need_checks,stk[MAX];</span><br><span class="line">&gt;<span class="keyword">bool</span> check[<span class="number">150</span>],flag,spj,chk;</span><br><span class="line">&gt;<span class="keyword">char</span> s[<span class="number">3010</span>],o,stkk[MAX]; </span><br><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">&gt;<span class="built_in">memset</span>(check,<span class="number">0</span>,<span class="keyword">sizeof</span>(check));</span><br><span class="line">&gt;<span class="built_in">memset</span>(stkk,<span class="number">0</span>,<span class="keyword">sizeof</span>(stkk));</span><br><span class="line">&gt;<span class="built_in">memset</span>(stk,<span class="number">0</span>,<span class="keyword">sizeof</span>(stk));</span><br><span class="line">&gt;now=t=tt=cntf=cnte=res=flag=spj=chk=<span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>$ps:$虽然不知道用一个二进制位的$0$来初始化字符数组会怎样……不过好像海星。</p><p>$cnte$和$cntf$用来记录$F$和$E$的数量，$num$、$t$、$tt$都是栈的指针，$spj$用来判断一个独立循环是否结束（如果结束就把当前的得到压入栈）,$now$用来搭配$spj$记录当前独立循环体的时间复杂度， $chk$用于读入每个程序的第一行（即含有需要判断的时间复杂度的那一行），$flag$用于判断输出。</p><p><strong>主要操作</strong></p><p>对于读入的东西，分类讨论，然后$continue$……没什么可说的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">while</span>(l--)&#123;</span><br><span class="line">&gt;     gets(s);</span><br><span class="line">&gt;     <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="built_in">strlen</span>(s);)&#123;</span><br><span class="line">&gt;      <span class="keyword">while</span>(s[i]==<span class="string">' '</span>)i++;</span><br><span class="line">&gt;<span class="keyword">if</span>(s[i]==<span class="string">'F'</span>)&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(cntf&gt;cnte&amp;&amp;cnte)&#123;</span><br><span class="line">&gt;ans[++num]=now;</span><br><span class="line">&gt;now=<span class="number">0</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;           cntf++,i++;</span><br><span class="line">&gt;           <span class="keyword">continue</span>;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;       <span class="keyword">if</span>(s[i]==<span class="string">'E'</span>)&#123;</span><br><span class="line">&gt;       y=stk[t],t--;</span><br><span class="line">&gt;x=stk[t],t--;</span><br><span class="line">&gt;           cnte++;</span><br><span class="line">&gt;           <span class="keyword">if</span>(cnte==cntf)spj=<span class="number">1</span>;</span><br><span class="line">&gt;           <span class="keyword">if</span>(x!=MAX)&#123;</span><br><span class="line">&gt;           <span class="keyword">if</span>(y==MAX)now++;</span><br><span class="line">&gt;           <span class="keyword">if</span>(y&lt;x)now=<span class="number">0</span>;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;           <span class="keyword">else</span>&#123;</span><br><span class="line">&gt;           <span class="keyword">if</span>(y!=MAX)now=<span class="number">0</span>;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;           check[stkk[tt]-<span class="string">'a'</span>]=<span class="number">0</span>;</span><br><span class="line">&gt;           tt--,i++;</span><br><span class="line">&gt;           <span class="keyword">if</span>(spj)&#123;</span><br><span class="line">&gt;           ans[++num]=now;</span><br><span class="line">&gt;now=<span class="number">0</span>;</span><br><span class="line">&gt;spj=<span class="number">0</span>;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;<span class="keyword">continue</span>;</span><br><span class="line">&gt;       &#125;</span><br><span class="line">&gt;           <span class="keyword">if</span>(!<span class="built_in">isdigit</span>(s[i])&amp;&amp;s[i]!=<span class="string">'n'</span>)&#123;</span><br><span class="line">&gt;           <span class="keyword">if</span>(check[s[i]-<span class="string">'a'</span>]&amp;&amp;!flag)&#123; </span><br><span class="line">&gt;           <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;           flag=<span class="number">1</span>;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;           stkk[++tt]=s[i];</span><br><span class="line">&gt;           check[s[i]-<span class="string">'a'</span>]=<span class="number">1</span>;</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;       <span class="keyword">else</span> &#123;  </span><br><span class="line">&gt;           <span class="keyword">if</span>(s[i]==<span class="string">'n'</span>)&#123;</span><br><span class="line">&gt;       my_push(s[i],s[i+<span class="number">1</span>]);</span><br><span class="line">&gt;i+=<span class="number">2</span>;</span><br><span class="line">&gt;           &#125;               </span><br><span class="line">&gt;           my_push(s[i],s[i+<span class="number">1</span>]);</span><br><span class="line">&gt;           &#125;</span><br><span class="line">&gt;       i++;</span><br><span class="line">&gt;     &#125;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>唯一需要注意的是入栈操作，因为要把字符压入整型，所以我又写了个函数来入栈。入栈的时候当然需要注意是不是两位数……</p><p>哦，还有，如果这次轮到$n$入栈了，那么就随便入栈一个大于一百的数即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;<span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">my_push</span><span class="params">(<span class="keyword">char</span> a,<span class="keyword">char</span> b)</span></span>&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(<span class="built_in">isdigit</span>(a))&#123;</span><br><span class="line">&gt;<span class="keyword">if</span>(<span class="built_in">isdigit</span>(b))&#123;</span><br><span class="line">&gt;stk[++t]=(a<span class="number">-48</span>)*<span class="number">10</span>+b<span class="number">-48</span>;</span><br><span class="line">&gt;i++;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">else</span> stk[++t]=a<span class="number">-48</span>; </span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;<span class="keyword">if</span>(a==<span class="string">'n'</span>)stk[++t]=MAX;</span><br><span class="line">&gt;&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>最后判断一下输入输出即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;   <span class="keyword">if</span>(!flag&amp;&amp;cntf!=cnte)&#123;</span><br><span class="line">&gt;     <span class="built_in">cout</span>&lt;&lt;<span class="string">"ERR"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;     flag=<span class="number">1</span>;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;   <span class="keyword">while</span>(num)&#123;</span><br><span class="line">&gt;     res=max(res,ans[num]); </span><br><span class="line">&gt;     num--;</span><br><span class="line">&gt;  &#125;</span><br><span class="line">&gt;  <span class="keyword">if</span>(!flag) <span class="keyword">if</span>(res==need_check) <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;   <span class="keyword">else</span>  <span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>嗯~o(<em>￣▽￣</em>)o这就是满分做法了。</p></blockquote><p>唉，时光一去不复返啊。</p><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><p>……其实不算是个新题，只是似乎当时这道题场上很卡常？感觉就是好多东西的杂糅，先SPFA判个全$0$环，再倒着记搜一遍……感觉已经不算什么新题了，T3出成这样感觉很失望qaq……</p><p>但怎么说呢，也是个练习码力的机会吧，转移方程挺好想的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">deque</span> &lt;<span class="keyword">int</span>&gt; q ;  </span><br><span class="line"><span class="built_in">bitset</span> &lt;MAXN&gt; vis ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> fr, to, next, v ;</span><br><span class="line">&#125;E[MAXM] ; <span class="keyword">int</span> head[MAXN][<span class="number">2</span>], cnt ;</span><br><span class="line"><span class="keyword">int</span> T, N, L, M, K, P, A, B, C, ss[MAXN] ;</span><br><span class="line"><span class="keyword">int</span> Es[MAXM][<span class="number">2</span>], dfn[MAXN], low[MAXN], tot ; </span><br><span class="line"><span class="keyword">bool</span> flag ; LL Ans, dp[MAXN][MAXK], dist[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span> _Add(<span class="keyword">int</span> u, <span class="keyword">int</span> v, <span class="keyword">int</span> w)&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].v = w, E[cnt].next = head[u][<span class="number">1</span>], head[u][<span class="number">1</span>] = cnt ; </span><br><span class="line">E[++ cnt].to = u, E[cnt].v = w, E[cnt].next = head[v][<span class="number">0</span>], head[v][<span class="number">0</span>] = cnt ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> k ; </span><br><span class="line">vis.reset() ;</span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-63</span>, <span class="keyword">sizeof</span>(dp)), cnt = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt;= L + <span class="number">3</span> ; ++ k) </span><br><span class="line">dist[k] = Inf, ss[k] = head[k][<span class="number">1</span>] = head[k][<span class="number">0</span>] = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">SPFA</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> now, k ; </span><br><span class="line">q.push_front(<span class="number">1</span>), vis[<span class="number">1</span>] = <span class="number">1</span>, dist[<span class="number">1</span>] = <span class="number">0</span>, ++ ss[<span class="number">1</span>] ;</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">now = q.front(), vis[now] = <span class="number">0</span>, q.pop_front() ;</span><br><span class="line"><span class="keyword">for</span> (k = head[now][<span class="number">1</span>] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (dist[to(k)] &gt;= dist[now] + E[k].v)&#123;</span><br><span class="line">++ ss[to(k)] ; </span><br><span class="line">dist[to(k)] = dist[now] + E[k].v ;</span><br><span class="line"><span class="keyword">if</span> (ss[to(k)] &gt;= N)&#123; flag = <span class="number">1</span> ; <span class="keyword">return</span> ; &#125;</span><br><span class="line"><span class="keyword">if</span> (!vis[to(k)])&#123;</span><br><span class="line"><span class="keyword">if</span> (q.empty() || dist[to(k)] &lt; dist[q.front()]) </span><br><span class="line">q.push_front(to(k)) ; <span class="keyword">else</span> q.push_back(to(k)) ; vis[to(k)] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;  </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">LL <span class="title">dp_work</span><span class="params">(<span class="keyword">int</span> now, <span class="keyword">int</span> op)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dp[now][op] &gt;= <span class="number">0</span>) <span class="keyword">return</span> dp[now][op] ; dp[now][op] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">register</span> <span class="keyword">int</span> k = head[now][<span class="number">0</span>] ; k ; k = E[k].next)&#123;</span><br><span class="line">LL t = op - dist[to(k)] + dist[now] - E[k].v ; </span><br><span class="line"><span class="keyword">if</span> (t &gt; K || t &lt; <span class="number">0</span>) <span class="keyword">continue</span> ; dp[now][op] = (dp[now][op] + dp_work(to(k), t)) % P ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[now][op] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> i ; <span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span>(T --)&#123;</span><br><span class="line">L = <span class="number">200000</span>, Init() ; Ans = <span class="number">0</span> ;</span><br><span class="line">N = qr(), M = qr(), K = qr(), P = qr() ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) A = qr(), B = qr(), C = qr(), _Add(A, B, C) ;</span><br><span class="line">SPFA() ; dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span> ; L = N ; <span class="keyword">if</span> (flag) &#123; flag = <span class="number">0</span>, <span class="built_in">printf</span>(<span class="string">"-1\n"</span>) ; <span class="keyword">continue</span> ; &#125; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= K ; ++ i) Ans = (Ans + dp_work(N, i)) % P ; <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, Ans) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想了一下，似乎出题人是故意把时间押给$B$的，所以$C$比较送。</p><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p>也是挺送的一道题，注意开<code>long long</code>就好…用并查集维护一下最上面和最下面的两个洞在不在一条“连通链”上即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hole</span>&#123;</span></span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> x,y,z;</span><br><span class="line">&#125;c[<span class="number">10001</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">long</span> <span class="keyword">long</span> <span class="title">find</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(f[a]!=a)a=find(f[a]);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">unionn</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> xz,<span class="keyword">long</span> <span class="keyword">long</span>  yz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(c[find(yz)].z&gt;c[find(xz)].z) f[find(yz)]=f[find(xz)];</span><br><span class="line"><span class="keyword">else</span> f[find(xz)]=f[find(yz)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">check</span><span class="params">(hole a,hole b)</span>z</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> d;</span><br><span class="line">    d=(a.z-b.z)*(a.z-b.z)+(a.y-b.y)*(a.y-b.y)+(a.x-b.x)*(a.x-b.x);</span><br><span class="line">    <span class="keyword">if</span>(d&lt;=<span class="number">4</span>*r*r)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;t;</span><br><span class="line"><span class="keyword">while</span>(t--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(f,<span class="number">0</span>,<span class="keyword">sizeof</span>(<span class="number">0</span>));</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n&gt;&gt;h&gt;&gt;r;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%lld%lld%lld"</span>,&amp;c[i].x,&amp;c[i].y,&amp;c[i].z);</span><br><span class="line">    f[i]=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> j=i+<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">      <span class="keyword">if</span>(f[i]!=f[j]&amp;&amp;check(c[i],c[j]))unionn(i,j);</span><br><span class="line">    <span class="keyword">bool</span> cc=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">long</span> <span class="keyword">long</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">      <span class="keyword">if</span>(c[i].z+r&gt;=h&amp;&amp;c[find(i)].z-r&lt;=<span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">  cc=<span class="number">1</span>;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;<span class="string">"Yes"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span>(!cc)<span class="built_in">cout</span>&lt;&lt;<span class="string">"No"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  cc=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>wtm以前的码风是有多犀利啊，字符间不加空格大括号也不换行</del></p><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><p>emmm第一眼状压，第二眼需要把树高加到状态里，那么就是$f_{s,h}$表示现在选的点集为$S$，树高为$h$的最小花费。转移的时候大概就是朴素的<br>$$<br>f_{s,i} = \min\limits _{t \in s}{f_{t,i-1}+cost_{t\to s}}<br>$$</p><p>然后这个cost显然是可以在可接受的复杂度以内$prework$出来的。于是最终的复杂度就是$\Theta(3^n\cdot n^2)$</p><blockquote><p>求“子集的子集”的复杂度严格来讲是$3^n$而不是$4^n$，原因在于我们事实上一共有$\sum \binom{n}{k}2^k$个子集，逆向二项式展开<del>或者叫二项式收缩</del>一下就可以得到$$\sum \binom{n}{k}2^k = \sum \binom{n}{k}1^{n-k}\cdot 2^k = (1+2)^n = 3^n$$代码实现：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">for</span>(t = S ; t ; t = (t - <span class="number">1</span>) &amp; S)</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></p></blockquote><blockquote><p>呃，至于这句话的原理暂不可知，但是挺好用是真的qwq</p></blockquote><p>但是复杂度上限此时是$531441\times 12^2= 76527504$，不可过（但事实上根本不可能跑满所以也过了），以下是<code>Flash_hu</code>巨佬的$\Theta(3^nn)$的做法：</p><p>我们发现似乎同一树高的所有节点，完全可以同时转移。所以我们不妨设$f_{s,t}$表示已选点集为$s$，下一层要加入的点集为$t$时， 新加入的所有点与原有点之间最小的边权之和——用于预处理。 具体的转移我们可以考虑如下：</p><p>$$<br>f_{s,t} = \min {f_{s,t-lowbit(j)}+cost_{k, s}}, k=\log _2lowbit(j)<br>$$<br>其中$cost_{k,s}$表示点$k$到连通块$s$的最短距离。可以用$lowbit$的原因是答案无序，所以这一部分的复杂度是$O(3^nn).$</p><p>那么接下来考虑原先的$dp$，设$g_{s,h}$表示已选点集为$s$，当前树高为$h$的最小代价，即目标函数。那么转移就是：<br>$$<br>g_{s,h} = \sum_{t\in s}g_{s-t, h-1}+h\cdot f_{s-t,t}<br>$$<br>同样是显然的。所以最后的复杂度就是$O(3^nn)$ 。答案的话最后直接对所有$g_{_{2^n-1,h}},h\in[1,n]$取个最小值就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> cnt, T, D[MAX][MAX], a, b, c ;</span><br><span class="line"><span class="keyword">int</span> F[MAXN][MAX], Next[MAX], Ans, Sup, Now ;</span><br><span class="line"><span class="keyword">int</span> N, M, i, j, k, Log[MAX], Max, A[MAXN][MAXN] ;   </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(A, <span class="number">63</span>, <span class="keyword">sizeof</span>(A)) ;</span><br><span class="line">    <span class="built_in">memset</span>(F, <span class="number">63</span>, <span class="keyword">sizeof</span>(F)), Ans = Inf ;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; Max = (<span class="number">1</span> &lt;&lt; N) - <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c), </span><br><span class="line">        A[a][b] = A[b][a] = min(c, A[a][b]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Log[<span class="number">1</span> &lt;&lt; i] = i ; </span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) F[<span class="number">0</span>][<span class="number">1</span> &lt;&lt; i] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= Max ; ++ i)&#123;</span><br><span class="line">        cnt = <span class="number">0</span> ;</span><br><span class="line">        <span class="keyword">for</span> (j = Sup = Max ^ i; j ; j = (j - <span class="number">1</span>) &amp; Sup) Next[j] = cnt, cnt = j ;</span><br><span class="line">        <span class="keyword">for</span> (j = cnt ; j ; j = Next[j])&#123;</span><br><span class="line">            Now = Log[j &amp; (-j)] + <span class="number">1</span>, T = Inf ;</span><br><span class="line">            <span class="keyword">for</span> (k = <span class="number">1</span>; k &lt;= N ; ++ k)</span><br><span class="line">                <span class="keyword">if</span> (<span class="number">1</span> &lt;&lt; (k - <span class="number">1</span>) &amp; i) T = min(T, A[Now][k]) ; </span><br><span class="line">            D[i][j] = D[i][j ^ (j &amp; -j)] + T ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) </span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= Max; ++ j)</span><br><span class="line">            <span class="keyword">for</span> (k = j ; k ; k = (k - <span class="number">1</span>) &amp; j)</span><br><span class="line">                F[i][j] = min(F[i][j], F[i - <span class="number">1</span>][j ^ k] + i * D[j ^ k][k]) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= N ; ++ i) Ans = min(Ans, F[i][Max]) ;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><p>一道我不是很会的线段树题……</p><p>怎么说呢，感觉这个做法未曾见过吧。大概就是维护$n+1$棵动态开点的线段树，其中对每一行的前$m-1$个元素维护一个线段树，然后对最后一列单独维护一棵线段树。线段树上每个点维护自己子树内到底有多少个点被删了，用来协助寻找现在的位置。在此基础上再维护$n+1$个<code>vector</code>，用来记录从每棵线段树中弹出的点即可。</p><p>呃，现在的我似乎并没有很好地理解这个题的做法，有些马虎…所以希望日后再看的时候能看的更清明一点吧。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> N, M, Q ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span> ; <span class="keyword">char</span> c = getchar() ; <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c)) c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ; <span class="keyword">return</span> k ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> vio&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAXV 2010</span></span><br><span class="line">    <span class="keyword">int</span> x, y, t, i, j ; </span><br><span class="line">    <span class="keyword">int</span> base[MAXV][MAXV] ;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Solve1</span><span class="params">()</span></span>&#123;</span><br><span class="line">        t = <span class="number">0</span> ; </span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">            <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">                base[i][j] = ++ t ; </span><br><span class="line">        <span class="keyword">while</span>(Q --)&#123;</span><br><span class="line">            x = qr(), y = qr(), t = base[x][y] ;</span><br><span class="line">            <span class="keyword">for</span> (i = y + <span class="number">1</span> ; i &lt;= M ; ++ i) base[x][i - <span class="number">1</span>] = base[x][i] ; </span><br><span class="line">            <span class="keyword">for</span> (i = x + <span class="number">1</span> ; i &lt;= N ; ++ i) base[i - <span class="number">1</span>][M] = base[i][M] ; </span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (base[N][M] = t)) ; </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> segment_T&#123;</span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> MAXN 400010</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> pb push_back</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">define</span> rr register int</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;ll&gt; del[MAXN &lt;&lt; <span class="number">4</span>] ; <span class="keyword">int</span> Max ; </span><br><span class="line">    <span class="keyword">int</span> rt[MAXN &lt;&lt; <span class="number">4</span>], L[MAXN &lt;&lt; <span class="number">4</span>], R[MAXN &lt;&lt; <span class="number">4</span>], dfn, val[MAXN &lt;&lt; <span class="number">4</span>] ;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> &amp;root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) root = ++ dfn ; val[root] ++ ; <span class="keyword">if</span> (l == r) <span class="keyword">return</span> ; rr mid = (l + r) &gt;&gt; <span class="number">1</span> ; </span><br><span class="line">        <span class="keyword">if</span> (pos &lt;= mid) update(L[root], l, mid, pos) ; <span class="keyword">else</span> update(R[root], mid + <span class="number">1</span>, r, pos) ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> pos)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r) <span class="keyword">return</span> l ; rr mid = (l + r) &gt;&gt; <span class="number">1</span>, dif = mid - l + <span class="number">1</span> - val[L[root]] ; </span><br><span class="line">        <span class="keyword">if</span> (dif &gt;= pos) <span class="keyword">return</span> query(L[root], l, mid, pos) ; <span class="keyword">else</span> <span class="keyword">return</span> query(R[root], mid + <span class="number">1</span>, r, pos - dif) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">delcase2</span><span class="params">(<span class="keyword">int</span> x, ll y)</span></span>&#123;</span><br><span class="line">        rr now_p = query(rt[N + <span class="number">1</span>], <span class="number">1</span>, Max, x) ; update(rt[N + <span class="number">1</span>], <span class="number">1</span>, Max, now_p) ;</span><br><span class="line">        ll ret = now_p &lt;= N ? <span class="number">1L</span>L * now_p * M : del[N + <span class="number">1</span>][now_p - N - <span class="number">1</span>] ; del[N + <span class="number">1</span>].pb(y ? y : ret) ; <span class="keyword">return</span> ret ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> ll <span class="title">delcase1</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span>&#123;</span><br><span class="line">        rr now_p = query(rt[x], <span class="number">1</span>, Max, y) ; update(rt[x], <span class="number">1</span>, Max, now_p) ; </span><br><span class="line">        ll ret = now_p &lt; M ? <span class="number">1L</span>L * (x - <span class="number">1</span>) * M + now_p : del[x][now_p - M] ; del[x].pb(delcase2(x, ret)) ; <span class="keyword">return</span> ret ;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Solve2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        rr x, y ; Max = max(N, M) + Q ; </span><br><span class="line">        <span class="keyword">while</span> (Q --) x = qr(), y = qr(), <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, y != M ? delcase1(x, y) : delcase2(x, <span class="number">0</span>)) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; Q ;</span><br><span class="line">    <span class="keyword">if</span> (N &lt;= <span class="number">5000</span> &amp;&amp; M &lt;= <span class="number">5000</span>) vio :: Solve1() ;</span><br><span class="line">    <span class="keyword">else</span> segment_T :: Solve2() ;<span class="comment">/*pkspkspks*/</span> <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="varPhi"><a href="#varPhi" class="headerlink" title="$\varPhi$"></a>$\varPhi$</h1><p>现在来看，乐观估计，自己应该可以得到$100+100+100+100+55+30=485pts$，当且仅当自己的码力已经很强。如果是悲观估计，那大概是$100+70+40+80+55+30=375pts$。继续努力吧，现在还差得很远啊……</p>]]></content>
    
    <summary type="html">
    
      $NOIP2017$的泛做。
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="数学/扩展欧几里德" scheme="https://Flower233pks.github.io/blog/tags/%E6%95%B0%E5%AD%A6-%E6%89%A9%E5%B1%95%E6%AC%A7%E5%87%A0%E9%87%8C%E5%BE%B7/"/>
    
      <category term="动态规划-普通DP" scheme="https://Flower233pks.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="NOIP系列" scheme="https://Flower233pks.github.io/blog/tags/NOIP%E7%B3%BB%E5%88%97/"/>
    
      <category term="线段树" scheme="https://Flower233pks.github.io/blog/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
      <category term="暴力" scheme="https://Flower233pks.github.io/blog/tags/%E6%9A%B4%E5%8A%9B/"/>
    
  </entry>
  
  <entry>
    <title>舞蹈链(DLX)入门</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/11/dlx/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/11/dlx/</id>
    <published>2019-07-11T10:15:08.000Z</published>
    <updated>2019-07-25T10:06:00.896Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>“<br>在一个全集$X$中若干子集的集合为$S$，精确覆盖（$\boldsymbol{Exact~Cover}$）是指，$S$的子集$S*$，满足$X$中的每一个元素在$S*$中恰好出现一次。在计算机科学中，精确覆盖问题指找出这样的一种覆盖，或证明其不存在。<br>”</p><a id="more"></a><h1 id="0x01-精准覆盖问题"><a href="#0x01-精准覆盖问题" class="headerlink" title="$0x01$ 精准覆盖问题"></a>$0x01$ 精准覆盖问题</h1><p>……其实是一种决策问题，给定$n$行长度为$m$的$0,1$序列，要求选出一些行，使得每一列有且仅有一个$1$，这就是精准覆盖问题。</p><p>诚然，我搜索贼菜，所以暂且不考虑爆搜，引进一种叫做“X算法”的东西，其本质上是每次选取一行，之后删掉所有与这行冲突的行，同时删掉与这行冲突的列，成为一个更小的矩阵，迭代下去。如果什么时候删没了，就说明是一种可行解；否则恢复原来的状态。</p><p>我们思考这种简洁做法的流程，发现朴素的删除与恢复无非就是将矩阵的这一个元素由$0$或$1$赋值成$-1$，记录一下状态回溯的时候再赋值回去，整个过程十分地漫长且繁复。而所谓所谓的”<strong>舞蹈链算法</strong>$\rm{DLX~(Dancing-Links ~X ~Algorithm)}$“算法则是专门用来加速这一过程。</p><p>在本人看来，$\rm{DLX}$更像是一种包装好的数据结构，一种加速措施，能更好的让爆搜达到其理论复杂度（所以本质上还是爆搜XD）……不过说实话“像翩翩起舞的舞者”我倒是看不出来…我觉得更像是一对牛仔裤上拉链，拉来拉去的那种感觉……</p><p><del>诶，什么时候我的Preface开始这么意识流了啊</del></p><h1 id="0x02-text-Dancing-Links"><a href="#0x02-text-Dancing-Links" class="headerlink" title="$0x02$ $\text{Dancing-Links}$"></a>$0x02$ $\text{Dancing-Links}$</h1><p>其实算法的本质就是链表，这玩意儿插入删除都是$\Theta(1)$的。我们考虑建立一个<strong>十字循环链表</strong>，即每个元素在链表里是四联通的，并且左右成环、上下成环，目的是方便知道某些操作该什么时候停止。本质上来讲，一个求解矩阵（此处代指上文提到的$n$行$0,1$序列）初始的$\text{Dancing-Links}$ 共有$\text{1+m+Count(‘1’)}$ 个元素，其中$Count(‘1’)$指矩阵中$1$的个数。</p><p>前$\text{m+1}$个元素，大概就是列标元素（$m$个）左右连成一片，最左边的$0$号元素用来判断是否$\text{worked-out}$整个矩阵，和所有列标元素串成一条左右连通的链表。然后剩下的的元素就是真实存在的元素…该怎么连怎么连那种感觉…</p><p>那么每个元素记录$6$个值，上下左右和行标列标。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> l, r, u, d, co, ro ;</span><br><span class="line">&#125;B[MAX &lt;&lt; <span class="number">1</span>] ;</span><br></pre></td></tr></table></figure><p>初始化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[i].l = i - <span class="number">1</span>, B[i].r = i + <span class="number">1</span>, B[i].u = B[i].d = i ;</span><br><span class="line">B[M].r = <span class="number">0</span>, B[<span class="number">0</span>].l = M, cnt = M, <span class="built_in">memset</span>(Ro, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Ro))  ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中$R_o[]$数组记录每一行的第一个元素（第一个加进来的元素</p><p>然后<code>Insert</code>函数用于插入……毕竟是链表嘛<del>，就要有个链表的样子</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ;</span><br><span class="line">B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; </span><br><span class="line"><span class="keyword">if</span> (Ro[R] &lt; <span class="number">0</span>) Ro[R] = B[cnt].l = B[cnt].r = cnt ; </span><br><span class="line"><span class="keyword">else</span> B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后$C_s[]$数组用来记录每一列的元素个数，用来剪枝。</p><p>然后就是删除和恢复，都是以列为参数的函数，也都是很平凡的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].d ; i != C ; i = B[i].d)  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r)</span><br><span class="line">B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Back</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].u ; i != C ; i = B[i].u)  </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l)</span><br><span class="line">B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ;</span><br><span class="line">B[B[C].l].r = C, B[B[C].r].l = C ;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是主函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dance</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!B[<span class="number">0</span>].r)&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)(ans = step) ; &#125; <span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = B[<span class="number">0</span>].r ; i ; i = B[i].r) </span><br><span class="line">now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; </span><br><span class="line">Del(now_c) ; </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d) &#123;</span><br><span class="line">Ans[step] = B[i].ro ; <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line"><span class="keyword">if</span> (dance(step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span> ;  <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line"> &#125;</span><br><span class="line"> Back(now_c) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有个小剪枝，就是刚才说的$C_s[]$。如果每次从含有最少$1$的那一列开始删，似乎可以快好几倍。</p><p>我发现整理算法的文章写起来真是难受啊，还是意识流比较管用。</p><p>最后是全部的程序（<a href="https://www.luogu.org/problemnew/show/P4929" target="_blank" rel="noopener">$Luogu4929$</a>）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own Init</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king Done</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand work </span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 520</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX 30010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> l, r, u, d, co, ro ;</span><br><span class="line">&#125;B[MAX &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> cnt, ans ; </span><br><span class="line"><span class="keyword">int</span> N, M, Ans[MAX], Ro[MAX], Cs[MAX] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, <span class="built_in">memset</span>(Ro, <span class="number">-1</span>, <span class="keyword">sizeof</span>(Ro)) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= M ; ++ i) B[i].l = i - <span class="number">1</span>, B[i].r = i + <span class="number">1</span>, B[i].u = B[i].d = i ;</span><br><span class="line">    B[M].r = <span class="number">0</span>, B[<span class="number">0</span>].l = M, cnt = M  ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Insert</span><span class="params">(<span class="keyword">int</span> R, <span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    Cs[C] ++, B[++ cnt].ro = R, B[cnt].co = C ;</span><br><span class="line">    B[cnt].u = C, B[cnt].d = B[C].d, B[C].d = B[B[C].d].u = cnt ; </span><br><span class="line">    <span class="keyword">if</span> (Ro[R] &lt; <span class="number">0</span>) Ro[R] = B[cnt].l = B[cnt].r = cnt ; </span><br><span class="line">    <span class="keyword">else</span> B[cnt].l = B[Ro[R]].l, B[cnt].r = Ro[R], B[Ro[R]].l = B[B[Ro[R]].l].r = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Del</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    B[B[C].l].r = B[C].r, B[B[C].r].l = B[C].l ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].d ; i != C ; i = B[i].d)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r)</span><br><span class="line">            B[B[j].d].u = B[j].u, B[B[j].u].d = B[j].d, Cs[B[j].co] -- ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Back</span><span class="params">(<span class="keyword">int</span> C)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[C].u ; i != C ; i = B[i].u)  </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l)</span><br><span class="line">            B[B[j].d].u = j, B[B[j].u].d = j, Cs[B[j].co] ++ ;</span><br><span class="line">    B[B[C].l].r = C, B[B[C].r].l = C ;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dance</span><span class="params">(<span class="keyword">int</span> step)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!B[<span class="number">0</span>].r)&#123; <span class="keyword">return</span> (<span class="keyword">bool</span>)(ans = step) ; &#125; <span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[<span class="number">0</span>].r ; i ; i = B[i].r) </span><br><span class="line">        now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; </span><br><span class="line">    Del(now_c) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d) &#123;</span><br><span class="line">        Ans[step] = B[i].ro ; <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">        <span class="keyword">if</span> (dance(step + <span class="number">1</span>)) <span class="keyword">return</span> <span class="number">1</span> ;  <span class="keyword">for</span>(<span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line"> &#125;</span><br><span class="line"> Back(now_c) ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Done</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j)</span><br><span class="line">            &#123; <span class="built_in">cin</span> &gt;&gt; k ; <span class="keyword">if</span> (k) Insert(i, j) ;&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!dance(<span class="number">0</span>)) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No Solution!"</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; ans ; ++ i) <span class="built_in">printf</span>(<span class="string">"%d "</span>, Ans[i]) ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    I_used_to_rule_the_world___Seas_would_rise_when_I_gave_the_word___Now_in_the_morning_I_sleep_alone___Sweep_the_streets_I_used_to_own() ; </span><br><span class="line">    I_used_to_roll_the_dice___Feel_the_fear_in_my_enemy_s_eyes___Listen_as_the_crowd_would_sing_Now_the_old_king_is_dead__Long_live_the_king() ;</span><br><span class="line">    One_minute_I_held_the_key__Next_the_walls_were_closed_on_me__And_I_discovered_that_my_castles_stand__Upon_pillars_of_salt_pillars_of_sand() ; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; <span class="comment">/*</span></span><br><span class="line"><span class="comment">             I hear Jerusalem bells are ringing   Roman Cavalry choirs are singing</span></span><br><span class="line"><span class="comment">             Be my mirror my sword and shield     My missionaries in a foreign field</span></span><br><span class="line"><span class="comment">                For some reason I can't explain     Once you know there was never'</span></span><br><span class="line"><span class="comment">                Never an honest word     That was when I ruled the world</span></span><br><span class="line"><span class="comment">               */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;“&lt;br&gt;在一个全集$X$中若干子集的集合为$S$，精确覆盖（$\boldsymbol{Exact~Cover}$）是指，$S$的子集$S*$，满足$X$中的每一个元素在$S*$中恰好出现一次。在计算机科学中，精确覆盖问题指找出这样的一种覆盖，或证明其不存在。&lt;br&gt;”&lt;/p&gt;
    
    </summary>
    
      <category term="学习笔记" scheme="https://Flower233pks.github.io/blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="学习笔记" scheme="https://Flower233pks.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精准覆盖/舞蹈链/DLX" scheme="https://Flower233pks.github.io/blog/tags/%E7%B2%BE%E5%87%86%E8%A6%86%E7%9B%96-%E8%88%9E%E8%B9%88%E9%93%BE-DLX/"/>
    
  </entry>
  
  <entry>
    <title>用舞蹈链(DLX)解决一类数独问题</title>
    <link href="https://Flower233pks.github.io/blog/2019/07/11/dlx2/"/>
    <id>https://Flower233pks.github.io/blog/2019/07/11/dlx2/</id>
    <published>2019-07-11T10:15:08.000Z</published>
    <updated>2019-07-25T10:05:03.794Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>考虑精准覆盖问题的本质——我们把行看做决策，把列看做任务，那么其实质就是通过决策来完成任务。</p><p>那么我们来考虑数独问题的本质，对于一个$n^2\cdot n^2$的数独而言，他的目标函数有四个：</p><ul><li><p>1、$r(i,j):$对于第$i$行，必须要有数字$j$</p></li><li><p>2、$c(i,j):$对于第$i$列，必须要有数字$j$</p></li><li><p>3、$p(i,j):$对于第$i$个宫，必须要有数字$j$</p></li><li><p>4、$e(i,j):$对于第$(i,j)$个格子，必须要有数字</p></li></ul><p>由此可知，我们有$4\times (n^2\cdot n^2)$的任务量。</p><p>同时我们可以用$n^6$的状态表示我们的决策，即$(i,j,k)$表示第$i$行$j$列填了数字$k$。</p><p>结合两者考虑，我们可以建出一个新的网格图，有$n^6$行、$4n^4$列。考虑向网格中填“$1$”表示一个决策完成了一个任务，那么对于每一个决策$(i,j,k)$，它理应可以完成$4$个任务，所以一共有$16n^4$个1.</p><p>至此建模完毕，一个$n^2\cdot n^2$的数独问题可以转化成一个$n^6$行、$4n^4$列，有$16n^4$个$1$的精准覆盖问题。</p><a id="more"></a><p>下面是代码实现部分，以<a href="https://www.spoj.com/problems/SUDOKU/" target="_blank" rel="noopener">SPOJ1110-SUDOKU</a>为例：</p><ul><li>首先是对状态进行编号</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">encode</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> (a &lt;&lt; <span class="number">8</span>) + (b &lt;&lt; <span class="number">4</span>) + c + <span class="number">1</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">void</span> <span class="title">decode</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> &amp;a, <span class="keyword">int</span> &amp;b, <span class="keyword">int</span> &amp;c)</span></span>&#123; </span><br><span class="line">  x --, c = x % <span class="number">16</span>, x /= <span class="number">16</span>, b = x % <span class="number">16</span>, x /= <span class="number">16</span>, a = x ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理其实也很简单，就是i的后续状态(j,k)有$n^4=256$种组合，同理j的后续状态有$n^2=16$种组合。</p><p>然后就是连边，对于每个点判断一下，如果当前枚举到的数字是这个点的数字那么就需要<code>insert</code>，同理如果没有数字的话那就都<code>insert</code>一遍，毕竟比起有数字的点，可行的决策数要更多。至此我们就保证了原图中存在数字的方格被<code>insert</code>了，不存在数字的方格的所有可能情况也被<code>insert</code>了，之后直接<code>dance</code>就可以啦。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> t[O][O], op ;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> POS = <span class="number">0</span>, Row = <span class="number">1</span>, Col = <span class="number">2</span>, Sub = <span class="number">3</span> ; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line">read(), Init() ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; ++ j)&#123;</span><br><span class="line">t[i][j] = base[i][j] == <span class="string">'-'</span> ? <span class="number">0</span> : base[i][j] - <span class="number">64</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">16</span> ; ++ k)&#123;</span><br><span class="line"><span class="keyword">if</span> (t[i][j] &amp;&amp; t[i][j] != k + <span class="number">1</span>) <span class="keyword">continue</span> ;</span><br><span class="line">op = encode(i, j, k) ; </span><br><span class="line">          Insert(op, encode(POS, i, j)),</span><br><span class="line">Insert(op, encode(Row, i, k)), </span><br><span class="line">          Insert(op, encode(Col, j, k)), </span><br><span class="line">          Insert(op, encode(Sub, (i / <span class="number">4</span>) * <span class="number">4</span> + j / <span class="number">4</span>, k)) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">dance(<span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; ++ i, <span class="built_in">puts</span>(<span class="string">""</span>))</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">16</span> ; ++ j) <span class="built_in">printf</span>(<span class="string">"%c"</span>, (<span class="keyword">char</span>)(res[i][j] + <span class="number">65</span>)) ;</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">""</span>) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后是一道要求出所有解的题：<a href="https://www.luogu.org/problem/P1074" target="_blank" rel="noopener">NOIP2009D 靶形数独</a></p><p>此处需要我们求出所有可能的精准覆盖方案然后取最大值，于是小小改动一下<code>dance</code>就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">gs</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;x, <span class="keyword">const</span> <span class="keyword">int</span> &amp;y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || y == <span class="number">1</span> || x == <span class="number">9</span> || y == <span class="number">9</span> )   <span class="keyword">return</span> <span class="number">6</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">2</span> || y == <span class="number">2</span> || x == <span class="number">8</span> || y == <span class="number">8</span> )   <span class="keyword">return</span> <span class="number">7</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">3</span> || y == <span class="number">3</span> || x == <span class="number">7</span> || y == <span class="number">7</span> )   <span class="keyword">return</span> <span class="number">8</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">4</span> || y == <span class="number">4</span> || x == <span class="number">6</span> || y == <span class="number">6</span> )   <span class="keyword">return</span> <span class="number">9</span> ; <span class="keyword">return</span> <span class="number">10</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dance</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;step)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> now_c = B[<span class="number">0</span>].r ; </span><br><span class="line"><span class="keyword">if</span> (!now_c)&#123;</span><br><span class="line"><span class="keyword">int</span> x, y, z, ret = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; step ; ++ i)</span><br><span class="line">decode(ans[i], x, y, z), g[x][y] = z + <span class="number">1</span> ; </span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">9</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">9</span> ; ++ j)</span><br><span class="line">ret += g[i][j] * gs(i + <span class="number">1</span>, j + <span class="number">1</span>) ;</span><br><span class="line">res = max(res, ret) ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = now_c ; i ; i = B[i].r) </span><br><span class="line">    now_c = Cs[i] &lt; Cs[now_c] ? i : now_c ; Del(now_c) ;  </span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = B[now_c].d ; i != now_c ; i = B[i].d)&#123;</span><br><span class="line">ans[step] = B[i].ro ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = B[i].r ; j != i ; j = B[j].r) Del(B[j].co) ;</span><br><span class="line">dance(step + <span class="number">1</span>) ; </span><br><span class="line">    <span class="keyword">for</span> (rr <span class="keyword">int</span> j = B[i].l ; j != i ; j = B[j].l) Back(B[j].co) ;</span><br><span class="line">&#125;</span><br><span class="line">Back(now_c) ; <span class="keyword">return</span>  ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>撒花~ <del>（撒自己XD</del></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;考虑精准覆盖问题的本质——我们把行看做决策，把列看做任务，那么其实质就是通过决策来完成任务。&lt;/p&gt;
&lt;p&gt;那么我们来考虑数独问题的本质，对于一个$n^2\cdot n^2$的数独而言，他的目标函数有四个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;1、$r(i,j):$对于第$i$行，必须要有数字$j$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;2、$c(i,j):$对于第$i$列，必须要有数字$j$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;3、$p(i,j):$对于第$i$个宫，必须要有数字$j$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;4、$e(i,j):$对于第$(i,j)$个格子，必须要有数字&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由此可知，我们有$4\times (n^2\cdot n^2)$的任务量。&lt;/p&gt;
&lt;p&gt;同时我们可以用$n^6$的状态表示我们的决策，即$(i,j,k)$表示第$i$行$j$列填了数字$k$。&lt;/p&gt;
&lt;p&gt;结合两者考虑，我们可以建出一个新的网格图，有$n^6$行、$4n^4$列。考虑向网格中填“$1$”表示一个决策完成了一个任务，那么对于每一个决策$(i,j,k)$，它理应可以完成$4$个任务，所以一共有$16n^4$个1.&lt;/p&gt;
&lt;p&gt;至此建模完毕，一个$n^2\cdot n^2$的数独问题可以转化成一个$n^6$行、$4n^4$列，有$16n^4$个$1$的精准覆盖问题。&lt;/p&gt;
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="模型" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/%E6%A8%A1%E5%9E%8B/"/>
    
    
      <category term="学习笔记" scheme="https://Flower233pks.github.io/blog/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="精准覆盖/舞蹈链/DLX" scheme="https://Flower233pks.github.io/blog/tags/%E7%B2%BE%E5%87%86%E8%A6%86%E7%9B%96-%E8%88%9E%E8%B9%88%E9%93%BE-DLX/"/>
    
  </entry>
  
  <entry>
    <title>Prufer序列泛做</title>
    <link href="https://Flower233pks.github.io/blog/2019/05/26/Prufer%E5%BA%8F%E5%88%97%E6%B3%9B%E5%81%9A/"/>
    <id>https://Flower233pks.github.io/blog/2019/05/26/Prufer序列泛做/</id>
    <published>2019-05-26T07:17:10.000Z</published>
    <updated>2019-07-24T13:36:14.375Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>Prufer数列是无根树的一种数列，常用来求解树的计数问题。</p></blockquote><a id="more"></a><h1 id="Preface"><a href="#Preface" class="headerlink" title="$Preface$"></a>$Preface$</h1><p>嗯，最近学了学一个叫做<code>Prufer</code>序列的东西，然后主要是跟树的计数有关。</p><h2 id="基本概念与基本操作"><a href="#基本概念与基本操作" class="headerlink" title="基本概念与基本操作"></a>基本概念与基本操作</h2><p>首先下定义：Prufer序列是一个长度为$n-2$的序列。</p><p>我们考虑给定一棵带标号的无根树，找出编号最小的叶子节点，写下与它相邻的节点的编号，然后删掉这个叶子节点。反复执行这个操作直到只剩两个节点为止。由于节点数$n&gt;2$的树总存在叶子节点，因此一棵$n$个节点的无根树唯一地对应了一个长度为$n-2$的数列，数列中的每个数都在$1$到$n$的范围内。而这就是这棵树的$\boldsymbol{Prufer}$<strong>序列</strong>。</p><blockquote><p>为什么是$n-2$？</p><p>我们观察一棵树，$n-1$条无向边决定了总度数为$2n-2$，同时由于每个节点当自己是被删成叶子的时候不会被算进去，所以每个节点需要减去一的贡献，换句话说就是$Prufer$序列的长度为$n-2$。</p></blockquote><p>emmm然后一个比较平凡的结论就是<strong>$\boldsymbol{P rufer}$序列中某个编号出现的次数就等于这个编号的节点在无根树中的度数-1。</strong></p><p>同时我们接下来要不加证明地断言<strong>任何一个长为$n-2$、取值范围在$1$到$n$之间的数列都唯一地对应了一棵$n$个节点的无根树.</strong></p><p><del>严格证明大家可以去Mt67的博客上翻（</del></p><p>想要更好的意会以上内容，需要我们考虑如何实现Prufer的呈现与复原：(摘自<code>ProJ7-Jeffy</code>的博客)</p><p>（1）无根树转化为 $Prufer$ 序列。<br>首先定义无根树中度数为<code>1</code>的节点是叶子节点。<br>找到编号最小的叶子并删除，序列中添加与之相连的节点编号，重复执行直到只剩下<code>2</code>个节点。<br>如下图的树对应的 $Prufer$ 序列就是 <code>3，5，1，3</code>。<br><img src="1.png" alt><br>具体实现可以用一个 <code>set</code> 搞定，维护度数为 <code>1</code> 的节点。复杂度 $O(n\log n)$。<br>（2）$Prufer$序列转化为无根树。<br>设点集 <code>V={1,2,3,...,n}</code>，每次取出 $Prufer$ 序列中最前面的元素$u$，在<code>V</code>中找到编号最小的没有在 $Prufer$ 序列中出现的元素$v$，给 $u，v$ 连边然后分别删除，最后在 <code>V</code> 中剩下两个节点，给它们连边。最终得到的就是无根树。<br>具体实现也可以用一个 <code>set</code>，维护 $Prufer$ 序列中没有出现的编号。复杂度 $O(n\log n）$。 </p><h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><ul><li><p>$n$个点有标号无根树共有$n^{n-2}$种。</p><ul><li>$\rm{Proof}:$ 仔细想想…似乎Prufer序列一共$n-2$项，于是就乘法原理就好了……</li></ul></li><li>接上一个，有根树的话因为对于每种方案里面的$n$个点都可以当作根，所以总数量是$n^{n-2}\cdot n=n^{n-1}$。</li></ul><hr><ul><li><p>假设每个点的度数已经确定了，设第$i$号点的度数为$d_i$，则显然有$\sum_{i=1}^{n}(d_i - 1)=n-2$，那么对于每个节点度数确定的带标号无根树数量就是<br>$$<br>\frac{(n-2)!}{\prod_{i=1}^n(d_i-1)}<br>$$</p><ul><li>$\rm{Proof}:$ 大概是一个排列组合的思想，我们可以认为是一共$n$种元素，选$n-2$个，每种元素有且必须有$d_i-1$个，求排列数。然后比较显然的是$(n-2)!$是总排列数，而每个元素一共有$d_i-1$个位置，对于同一种元素的同一种位置排布，我们多算了$A_{(d_i-1)}^{(d_i-1)}=(d_i-1)!$次的，所以分母上乘法原理起来去除这些贡献就好。</li></ul></li><li><p>接上一个, $n$ 个节点的度依次为 $d_1,d_2,…,d_{n-m}$，另外有 $m$ 个节点度数未知，求有多少种生成树？</p><ul><li>我们考虑首先计算一下$Prufer$序列该剩下多少未知项，设其数目为$\omega$，则$\omega=(n-2)-\sum_{d_i ~is~known} (d_i-1)$。那么本着瞎**去重的原则，我们考虑应该在分母上乘一个$\omega!$。而同时由于我们存在$m$个度数并未确定的点，在$Prufer$序列中占据了$\omega$个位置，所以我们分子上应该再乘上一个$m^{\omega}$。故总方案数就变成了：</li></ul></li></ul><p>$$<br>\frac{(n-2)!m^{\omega}}{\omega!\cdot \prod_{i=1}^{n-m}(d_i-1)}<br>$$</p><h1 id="A-HNOI2008-明明的烦恼"><a href="#A-HNOI2008-明明的烦恼" class="headerlink" title="$A$ [HNOI2008]明明的烦恼"></a>$A$ [HNOI2008]明明的烦恼</h1><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1005" target="_blank" rel="noopener">bzoj1005</a></p><p>其实就是上面<code>扩展</code>里面的一个推论，然后我们就用<code>python</code>水过去就好了233</p><p><del>然而BZOJ的Py只会一直Pending，所以还是什么时候再写一发高精度吧</del></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">N = input()</span><br><span class="line">Fac = [<span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, N - <span class="number">1</span>) :</span><br><span class="line">    Fac = Fac + [Fac[i - <span class="number">1</span>] * i]</span><br><span class="line">Ans = Fac[N - <span class="number">2</span>]</span><br><span class="line">cnt = <span class="number">0</span></span><br><span class="line">Sum = N - <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, N) :</span><br><span class="line">    di = input()</span><br><span class="line">    <span class="keyword">if</span> di == <span class="number">-1</span> :</span><br><span class="line">    cnt = cnt + <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> : </span><br><span class="line">        Ans = Ans / Fac[di - <span class="number">1</span>]</span><br><span class="line">        Sum = Sum - (di - <span class="number">1</span>)</span><br><span class="line">Ans = Ans / Fac[Sum]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>, Sum) :</span><br><span class="line">    Ans = Ans * cnt</span><br><span class="line"><span class="keyword">print</span> (Ans)</span><br></pre></td></tr></table></figure><h1 id="B-小猴打架"><a href="#B-小猴打架" class="headerlink" title="$B$ 小猴打架"></a>$B$ 小猴打架</h1><p>由于在BZOJ上是权限题，所以不得已去Luogu做…<del>国内最大的盗版题市场</del></p><p><a href="https://www.luogu.org/problemnew/show/P4430" target="_blank" rel="noopener">Luogu4430</a></p><p> 我们发现这个题的Aim在于让我们求无根树有多少种不同的生成方式，比普通的Prufer序列多一个加边的顺序——毕竟Prufer只能处理树的形态不同&amp;标号不同，所以我们理所当然地乘上一个$(n-1)!$。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;<span class="comment">//用sb代码来填补博文太短的空白</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; Frac[<span class="number">0</span>] = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt; N ; ++ i) (Ans *= N) %= Mod ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) Frac[i] = Frac[i - <span class="number">1</span>] * i % Mod ;</span><br><span class="line">(Ans *= Frac[N - <span class="number">1</span>]) %= Mod, <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;Prufer数列是无根树的一种数列，常用来求解树的计数问题。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Prufer序列" scheme="https://Flower233pks.github.io/blog/tags/Prufer%E5%BA%8F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>$B-BFS￥泛做</title>
    <link href="https://Flower233pks.github.io/blog/2019/05/26/BBFS%E6%B3%9B%E5%81%9A/"/>
    <id>https://Flower233pks.github.io/blog/2019/05/26/BBFS泛做/</id>
    <published>2019-05-26T07:01:56.000Z</published>
    <updated>2019-07-24T14:04:21.865Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>$B-BFS$其实就是Binary-system BFS的简写，或者更详细的说只是一种建图的方式。<br><a id="more"></a></p><h1 id="Preface"><a href="#Preface" class="headerlink" title="Preface"></a>Preface</h1><p> 就是瞎做题，最近在一股脑把做过的题都整理一遍……包括水题</p><h1 id="A-HAOI2008-移动玩具"><a href="#A-HAOI2008-移动玩具" class="headerlink" title="A [HAOI2008]移动玩具"></a>A [HAOI2008]移动玩具</h1><p><a href="https://www.lydsy.com/JudgeOnline/problem.php?id=1054" target="_blank" rel="noopener">bzoj1054</a></p><p>据说做这种题会有什么很奇妙的做法，但我的做法就是给每个二进制状态标一个号，sb连边之后再去暴力BFS求最短路……反正就是一道SB题就对了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 20</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> zt (1 &lt;&lt; 16)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[zt &lt;&lt; <span class="number">6</span>] ; <span class="keyword">int</span> head[zt &lt;&lt; <span class="number">1</span>], ct ;</span><br><span class="line"><span class="keyword">int</span> dx[<span class="number">4</span>] = &#123;<span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, dy[<span class="number">4</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125; ; </span><br><span class="line"><span class="keyword">int</span> N, S, T_, A[MAXN][MAXN][MAXN], T[MAXN][MAXN], t[MAXN], dist[zt &lt;&lt; <span class="number">1</span>] ;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">E[++ ct].to = v, E[ct].next = head[u], head[u] = ct ; </span><br><span class="line">E[++ ct].to = u, E[ct].next = head[v], head[v] = ct ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> que[zt &lt;&lt; <span class="number">5</span>] ;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">BFS</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> he = <span class="number">1</span>, ta = <span class="number">0</span> ; </span><br><span class="line">dist[S] = <span class="number">1</span>, que[++ ta] = S;</span><br><span class="line"><span class="keyword">while</span> (he &lt;= ta)&#123;</span><br><span class="line">rr <span class="keyword">int</span> now = que[he ++] ;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> k = head[now] ; k ; k = E[k].next)</span><br><span class="line"><span class="keyword">if</span> (!dist[to(k)]) dist[to(k)] = dist[now] + <span class="number">1</span>, que[++ ta] = to(k) ;</span><br><span class="line"><span class="keyword">if</span> (dist[T_]) <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//freopen("1054.in", "r", stdin) ;</span></span><br><span class="line"><span class="comment">//freopen("1054.out", "w", stdout) ;</span></span><br><span class="line">N = (<span class="number">1</span> &lt;&lt; <span class="number">16</span>) - <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt;= N ; ++ i)&#123;</span><br><span class="line"><span class="built_in">memset</span>(t, <span class="number">0</span>, <span class="keyword">sizeof</span>(t)) ;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> kans = <span class="number">0</span>, tot = <span class="number">0</span>, cnt = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">4</span> ; ++ k)</span><br><span class="line">T[j][k] = (<span class="number">1</span> &lt;&lt; tot &amp; i) ? <span class="number">1</span> : <span class="number">0</span>, ++ tot ;<span class="comment">/*, cout &lt;&lt; T[j][k] &lt;&lt; " " ; </span></span><br><span class="line"><span class="comment">cout &lt;&lt; "==================================" &lt;&lt; endl ; */</span></span><br><span class="line">tot = <span class="number">0</span> ;<span class="comment">/*</span></span><br><span class="line"><span class="comment">for (k = 1 ; k &lt;= 4 ; ++ k)</span></span><br><span class="line"><span class="comment">for (l = 1 ; l &lt;= 4 ; ++ l)</span></span><br><span class="line"><span class="comment">kans |= ((1 &amp; T[k][l]) &lt;&lt; tot), ++ tot ;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; kans &lt;&lt; endl ; */</span></span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">4</span> ; ++ k)</span><br><span class="line"><span class="keyword">if</span> (T[j][k])</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> l = <span class="number">0</span> ; l &lt; <span class="number">4</span> ; ++ l)&#123;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> kx = j + dx[l], ky = k + dy[l] ;</span><br><span class="line"><span class="keyword">if</span> (kx &lt; <span class="number">1</span> || ky &lt; <span class="number">1</span> || kx &gt; <span class="number">4</span> || ky &gt; <span class="number">4</span> || T[kx][ky]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="built_in">memcpy</span>(A[++ cnt], T, <span class="keyword">sizeof</span>(T)), A[cnt][kx][ky] = <span class="number">1</span>, A[cnt][j][k] = <span class="number">0</span> ;  </span><br><span class="line">&#125; </span><br><span class="line">tot = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= cnt ; ++ j, tot = <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> k = <span class="number">1</span> ; k &lt;= <span class="number">4</span> ; ++ k)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> l = <span class="number">1</span> ; l &lt;= <span class="number">4</span> ; ++ l)</span><br><span class="line">t[j] |= (<span class="number">1</span> &amp; A[j][k][l]) &lt;&lt; tot, ++ tot ;</span><br><span class="line">Add(i, t[j]) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">register</span> <span class="keyword">int</span> tot = <span class="number">0</span> ; </span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;T[i][j]), S = S | ((<span class="number">1</span> &amp; T[i][j]) &lt;&lt; tot), ++ tot ;</span><br><span class="line">tot = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">1</span> ; i &lt;= <span class="number">4</span> ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> j = <span class="number">1</span> ; j &lt;= <span class="number">4</span> ; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%1d"</span>, &amp;T[i][j]), T_ = T_ | ((<span class="number">1</span> &amp; T[i][j]) &lt;&lt; tot) , ++ tot ;</span><br><span class="line">BFS() ; <span class="built_in">cout</span> &lt;&lt; dist[T_] - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="B-黑白棋游戏"><a href="#B-黑白棋游戏" class="headerlink" title="B  黑白棋游戏"></a>B  黑白棋游戏</h1><p><a href="https://www.luogu.org/problemnew/show/P1225" target="_blank" rel="noopener">Luogu1225</a></p><p>其实还是上面个sb题，但是我们要输出方案，于是我们就可以套个<code>struct+stack</code>输出方案：</p><p>哦，对了，<code>Pre</code>可以在BFS里面处理出来。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BFS() ; <span class="built_in">cout</span> &lt;&lt; dist[T_] - <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">while</span> (Pre[T_])&#123;</span><br><span class="line"><span class="keyword">int</span> P[<span class="number">4</span>], num = <span class="number">0</span> , kans = T_ ^ Pre[T_] ; </span><br><span class="line"><span class="keyword">for</span> (rr <span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">16</span> ; ++ i) <span class="keyword">if</span> (kans &amp; (<span class="number">1</span> &lt;&lt; i)) P[++ num] = i + <span class="number">1</span> ;</span><br><span class="line">ans.push( (Ans)&#123;P[<span class="number">1</span>] / <span class="number">4</span> + (<span class="keyword">bool</span>)(P[<span class="number">1</span>] % <span class="number">4</span>), ((P[<span class="number">1</span>] % <span class="number">4</span>) ? P[<span class="number">1</span>] % <span class="number">4</span> : <span class="number">4</span>), P[<span class="number">2</span>] / <span class="number">4</span> + (<span class="keyword">bool</span>)(P[<span class="number">2</span>] % <span class="number">4</span>), ((P[<span class="number">2</span>] % <span class="number">4</span>) ? P[<span class="number">2</span>] % <span class="number">4</span> : <span class="number">4</span>)&#125;), T_ = Pre[T_] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (!ans.empty()) <span class="built_in">cout</span> &lt;&lt; ans.top().a &lt;&lt; ans.top().b &lt;&lt; ans.top().c &lt;&lt; ans.top().d &lt;&lt; <span class="built_in">endl</span>, ans.pop() ;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;$B-BFS$其实就是Binary-system BFS的简写，或者更详细的说只是一种建图的方式。&lt;br&gt;
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="BZOJ" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/BZOJ/"/>
    
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>可持久化数据结构·主席树杂谈</title>
    <link href="https://Flower233pks.github.io/blog/2019/05/18/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%BB%E5%B8%AD%E6%A0%91%E6%9D%82%E8%B0%88/"/>
    <id>https://Flower233pks.github.io/blog/2019/05/18/可持久化数据结构·主席树杂谈/</id>
    <published>2019-05-18T07:08:52.000Z</published>
    <updated>2019-05-18T07:08:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/blog/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/blog/assets/js/APlayer.m
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>CF#Global Round 1の题解(A $\to$ G)</title>
    <link href="https://Flower233pks.github.io/blog/2019/05/10/Codeforces-1110/"/>
    <id>https://Flower233pks.github.io/blog/2019/05/10/Codeforces-1110/</id>
    <published>2019-05-10T09:12:43.000Z</published>
    <updated>2019-05-19T01:58:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>自从省选完之后状态一直不佳，感觉自己刚燃起的希望又熄灭了。所以就打算来整理一下省选之前因为懒而没整的一些题。然后你会发现前两句话一点关系都没有XD</p><p>这里是总链接<a href="http://codeforces.com/contest/1110" target="_blank" rel="noopener">$Link$</a>.</p><h1 id="A"><a href="#A" class="headerlink" title="$A$"></a>$A$</h1><p><img src="https://img.shields.io/badge/难度-普及－-yellow.svg" alt></p><p>题意：求$\sum_{i=1}^{k} a_i\times b^{k-i}$的奇偶性， $k = \Theta(n \log n)$ </p><p>……其实很容易想麻烦，比如说逐个判断，整体判断啥的。但其实只要对结果都$\bmod ~10$，然后判断奇偶性就好了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; b &gt;&gt; k ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= k ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;base[i]) ;</span><br><span class="line">   reverse (base + <span class="number">1</span>, base + k + <span class="number">1</span>) ;</span><br><span class="line">   <span class="keyword">for</span> (i = k ; i &gt;= <span class="number">1</span> ; -- i) Sum = Sum * b + base[i], Sum %= <span class="number">10</span> ;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; (Sum &amp; <span class="number">1</span> ? <span class="string">"odd"</span> : <span class="string">"even"</span>) &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p><del>其实就是在水字数</del></p><h1 id="B"><a href="#B" class="headerlink" title="$B$"></a>$B$</h1><p><img src="https://img.shields.io/badge/难度-普及%2B-red.svg" alt></p><p>题意： 给定一条网格纸，$n, m, k$,分别表示点数，总长度，胶带的数量。对于输入的$n$个点，保证位置递增， 求覆盖所有的点所需的最小胶带长度（胶带数量$\leq k$）。</p><p>其实是个制杖题。我们考虑如果$k$是无限大，那么最优的方式一定是单点覆盖。所以如果胶带不够的话，就是要去额外多粘$N-k$个空白的区间。所以我们就可以排个序，求出$N-k$个空白区间的长度，再加上单点的长度和$n$，得到答案。注意空白区间的两头开的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M &gt;&gt; K ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;now), (i &gt; <span class="number">1</span> ? (d[i - <span class="number">1</span>] = now - Last - <span class="number">1</span>) : <span class="number">1</span>), Last = now ;</span><br><span class="line">nth_element(d + <span class="number">1</span>, d + N - K + <span class="number">1</span>, d + N) ; <span class="comment">//Last row, now - Last + 1 -&gt; now - Last</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N - K ; ++ i) Ans += d[i] ; Ans += N ; <span class="built_in">cout</span> &lt;&lt; Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><p>emmm怎么说呢，是个显然又不显然的贪心，大概还是跟<code>OI素养</code>直接挂钩的吧（sigh</p><h1 id="C"><a href="#C" class="headerlink" title="$C$"></a>$C$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p><p>题目简述    :    定义函数$f(a)$<br>$$<br>f(a) = \max_{0 &lt; b &lt; a}{\gcd(a \oplus b, a > \&amp; > b)}<br>$$</p><p>给出 $q$ 个询问，每个询问为一个整数$a_i$。你需要对于每个询问，求出$f(a_i)$的值。$q=O(10^3),a=O(2^{25}).$</p><p>也算是比较巧妙的一道题，当然这个难度评级是给的分块打表的，毕竟思维难度摆在那里……首先我们考虑这个式子的结构，最大化一个gcd，那么我们不妨考虑如果$gcd(x,y)$,存在$x=0$或者$y=0$时，$gcd(x,y)=y$或者$gcd(x,y)=x$。</p><p>所以我们考虑，对于任意的$a$，我们只需要去尝试构造一种方案 ，使得$a\oplus b$最大并且$a~\&amp; ~b$最小。那么不妨考虑直接选一个与$a$所有位上都相反的数$b$，就可以保证$a~\oplus~b$最大且$a~\&amp;~b=0$，最后的答案就是$2^{k-1}-1$，其中$k$是二进制下$a$的位数。其中合法性是不言而喻的，因为根据构造，$b$的第$k$位（二进制位下最大的那一位）上必定是$0$，所以似乎就做完了？</p><p>然而并不是，因为$b\not =0$，所以当$~a=2^{w}-1，w\in \mathbb N~$时就会不合法。此处又有一个精妙的构造，我们发现当$a$的二进制位上都是$1$时，$\forall b&lt;a,\exists a  ~\&amp; ~b=b, a~\oplus~b=a-b$, 于是最后就相当于求$\max \gcd (a-b,b)$，运用辗转相除或者更相减损的思想可以立即看出是$\max \gcd(a,b)$，于是只需要找出$a$最大的因子就好了——此处暴力即可。</p><p>于是最后的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 34000000</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">bitset</span> &lt;MAXN&gt; check ; <span class="keyword">int</span> T, N, i, O ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get_fac</span><span class="params">(<span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">3</span> ; i &lt;= x ; i += <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">if</span> (!(x % i)) <span class="keyword">return</span> (x /= i) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123; </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= <span class="number">25</span> ; ++ i) check[(<span class="number">1</span> &lt;&lt; i) - <span class="number">1</span>] = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">while</span> (T --)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N) ;</span><br><span class="line">        <span class="keyword">if</span> (check[N]) </span><br><span class="line">            O = get_fac(N), <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, O) ;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; i &lt;&lt;= <span class="number">1</span>, O = i) ; </span><br><span class="line">            O --, <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, O) ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不得不说是一道比较神的的题了，Brainstorm，Brainstorm…..</p><h1 id="D"><a href="#D" class="headerlink" title="$D$"></a>$D$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p><p>题目详述：你在玩一个叫做 <code>Jongmah</code> 的游戏，你手上有 $n$ 个麻将，每个麻将上有一个在 $1$ 到 $m$ 范围内的整数 $a_i$。为了赢得游戏，你需要将这些麻将排列成一些三元组，每个三元组中的元素是相同的或者连续的。你只能使用手中的麻将，并且每个麻将只能使用一次。请求出你最多可以形成多少个三元组。</p><p><del>这道题准确预报了今年各省省选里面的毒瘤雀魂题</del></p><p>一道动态规划，感觉思路清新、解法自然<del>，给出题人点赞.</del> 然后底下是我丢到Luogu的题解：</p><blockquote><p>$dp.$</p><p>其实主要思想都差不多，但我发这篇$sol$为了阐明一种观点：复杂度同阶的$DP$，不同的状态设计，会导致代码难度、时空复杂度等截然不同。</p><p>我们定义状态$dp_{i,j_{1},j_{2}}$表示考虑了前$i$大序号的麻将($mahJong$)，其中有$j_{1}$个$[i - 1, i, i + 1]$类型、有$j_{2}$个$[i, i + 1, i + 2]$类型的组合，最多组成多少个三元组。</p><p>这样定义状态的原因是：我们发现如果单纯用$1$维状态转移，那么状态势必是“前$i$大序号的麻将包含的三元组个数”，但是此状态不明确——无法准确定义“包含”的意思。而此处我们定义包含指<strong>三元组右端点也$\leq i$</strong>，那么$[i - 1, i, i + 1]$和$[i, i + 1, i + 2]$便需要单独定义出来。</p><p>转移的时候直接枚举有多少个$[i + 1,i+2, i+3]$即可（因为我们使用$i$更新$i+1$而不是用$i-1$更新$i$，如是做细节少、思考难度小）</p></blockquote><p>然后转移的时候也要顺便计算$[i,i,i]$的数量。而由于如果存在三个$[i,i+1,i+2]$，那么我们直接拆成三个$[i,i,i]$，三个$[i+1,i+1,i+1]$, 三个$[i+2,i+2,i+2]$即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line"><span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="keyword">sizeof</span>(dp)), dp[<span class="number">0</span>][<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Sum[ qrd() ] ++ ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span> ; j &lt; <span class="number">3</span> ; ++ j)</span><br><span class="line">        <span class="keyword">for</span> (k = <span class="number">0</span> ; k &lt; <span class="number">3</span> ; ++ k)</span><br><span class="line">            <span class="keyword">for</span> (l = <span class="number">0</span> ; l &lt; <span class="number">3</span> ; ++ l)</span><br><span class="line">                <span class="keyword">if</span> (Sum[i] &lt; j + k + l) <span class="keyword">continue</span> ;</span><br><span class="line">                <span class="keyword">else</span> dp[i][k][l] = max(dp[i][k][l], dp[i - <span class="number">1</span>][j][k] + (Sum[i] - j - k - l)/<span class="number">3</span> + l) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dp[M][<span class="number">0</span>][<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br></pre></td></tr></table></figure><h1 id="E"><a href="#E" class="headerlink" title="$E$"></a>$E$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E6%8F%90%E9%AB%98%2B-blue.svg" alt></p><p>题目简述：给定数列$c$和$t$，每次操作都可以选择一个$1&lt;i&lt;n$，令$c_i$变成$c_i’$，其中$c_i’=c_{i+1}+c_{i-1}-c_i$。问是否可以经过若干次操作，使得$\forall c_i=t_i$. </p><p>……我管这种题叫做“疯狂暗示题”，其实也是一种做题技巧的问题。打完比赛反思了一下，似乎有好几个关键信息没有捕捉到。比如说“若干次操作”，没有限定操作次数，就说明无论怎么操作，其背后一定有某些本质不变的东西，否则应该出成一个交互题，在$k$步之内完成任务的那种感觉。而同时，每次操作一个$c_i$，都只会跟$c_{i-1}$、$c_{i+1}$有关。所以，一切的一切都在引导我们向<code>差分</code>靠拢。</p><p>我们思考对于一个$c_i$，令其满足$c_{i-1}+d_1=c_i, ~c_i+d_2=c_{i+1}$，那么我们新的$c_i’$就是</p><p>$$<br>c_i’=c_i-d_1+c_i+d_2-c_i=c_i-d_1+d_2<br>$$<br>那么我们就会发现<br>$$<br>c_{i+1}-c_i’ = d_1\\ c_i’-c_{i-1} = d_2<br>$$</p><p>换句话说，其实就是相邻两个差换了位置！那么也就是说无论怎样，差分数组里面每个数出现的次数都是不变的，直接排个序检查就好。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span> &gt;&gt; N ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;A[i]) ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;B[i]) ;</span><br><span class="line">   <span class="keyword">if</span> (A[<span class="number">1</span>] != B[<span class="number">1</span>] || A[N] != B[N]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) Da[i] = A[i] - A[i - <span class="number">1</span>] ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) Db[i] = B[i] - B[i - <span class="number">1</span>] ;</span><br><span class="line">   sort(Da + <span class="number">2</span>, Da + N + <span class="number">1</span>), sort(Db + <span class="number">2</span>, Db + N + <span class="number">1</span>) ;</span><br><span class="line">   <span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (Da[i] != Db[i]) <span class="keyword">return</span> <span class="built_in">puts</span>(<span class="string">"No"</span>), <span class="number">0</span> ; <span class="built_in">puts</span>(<span class="string">"Yes"</span>) ;</span><br></pre></td></tr></table></figure><p>感觉其实$C/D/E$都是比较好的思维题……但是接下来一个就不是了。</p><h1 id="F"><a href="#F" class="headerlink" title="$F$"></a>$F$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p><p>题目简述 ：给定一棵以$1$为根的$n$个节点有根树， 给定$m$次询问， 形如 <code>v l r</code>， 输出以$v$为起点，终点编号为$l$ ~$r$以内的叶子中最短的路径距离。</p><p>根据dfs序的相关知识，我们需要一棵线段树来维护dfs序上的路径长度最小值。但是很多人（比如我）会认为一定需要线段树上个树什么的，但其实有更简单的策略。</p><p>不妨直接令当前点到其他所有的点的距离是一个数组$dis$。思考如果我们把当前点的当前子节点设为$x$, 那么我们如果向下递归$x$，就会有$x$到$x$子树内的所有节点的$dis$，比其父亲的dis都小一个$E[k].v$，$x$到其他节点的距离都会大一个$E[k].v$，那么就如同状态转移一样，每次向下递归的时候先统计一遍$Ans$，再更新一下距离即可。</p><p>其实这个题是一个$tricky$题，比如我们为了用一个dis数组表示到叶子的距离，可以把非叶子之间的距离都设成$\rm{Inf}$ ；比如我们为了飞速统计答案，可以把询问离线下到一个<code>vector</code>里面，在dfs的时候直接统计出全部答案。</p><p>不失为一道好题啊qwq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Inf (1LL &lt;&lt; 55)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ; ll c ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> N, M, A, i, q ; </span><br><span class="line">ll tag[MAXN &lt;&lt; <span class="number">2</span>], S[MAXN &lt;&lt; <span class="number">2</span>], Ans[MAXN], dis[MAXN], B ;</span><br><span class="line"><span class="keyword">int</span> cnt, head[MAXN], Last[MAXN], Lr[MAXN], Rr[MAXN] ; <span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; query[MAXN] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">min</span><span class="params">(<span class="keyword">const</span> ll &amp;a, <span class="keyword">const</span> ll &amp;b)</span></span>&#123; <span class="keyword">return</span> a &lt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">max</span><span class="params">(<span class="keyword">const</span> ll &amp;a, <span class="keyword">const</span> ll &amp;b)</span></span>&#123; <span class="keyword">return</span> a &gt; b ? a : b ; &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line">Last[u] = u ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ; </span><br><span class="line">dis[to(k)] = dis[u] + E[k].c ; </span><br><span class="line">dfs(to(k), u), Last[u] = max(Last[u], Last[to(k)]) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v, ll w)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].c = w, </span><br><span class="line">E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, E[cnt].c = w, </span><br><span class="line">E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_up</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123; </span><br><span class="line">S[rt] = min(S[rt &lt;&lt; <span class="number">1</span>], S[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]) ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">push_down</span><span class="params">(<span class="keyword">int</span> rt)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tag[rt] == <span class="number">0</span>) <span class="keyword">return</span> ;</span><br><span class="line">rr <span class="keyword">int</span> lc = rt &lt;&lt; <span class="number">1</span>, rc = rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line">tag[lc] += tag[rt], tag[rc] += tag[rt], </span><br><span class="line">S[lc] += tag[rt], S[rc] += tag[rt], tag[rt] = <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ul, <span class="keyword">int</span> ur, ll k)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(ul &lt;= l &amp;&amp; ur &gt;= r)&#123;</span><br><span class="line">S[rt] += k, tag[rt] += k ; <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line">push_down(rt) ; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">if</span> (ul &lt;= mid) update(rt &lt;&lt; <span class="number">1</span>, l, mid, ul ,ur, k) ;</span><br><span class="line"><span class="keyword">if</span> (ur &gt; mid) update(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ul, ur, k) ; push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">S[rt] = dis[l] ; <span class="keyword">return</span> ; </span><br><span class="line">&#125; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">build(rt &lt;&lt; <span class="number">1</span>, l, mid), build(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r), push_up(rt) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ll <span class="title">querys</span><span class="params">(<span class="keyword">int</span> rt, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> ql, <span class="keyword">int</span> qr)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (ql &lt;= l &amp;&amp; r &lt;= qr) <span class="keyword">return</span> S[rt] ;</span><br><span class="line">rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ; rr ll res = Inf ; push_down(rt) ;</span><br><span class="line"><span class="keyword">if</span> (ql &lt;= mid) res = min(res, querys(rt &lt;&lt; <span class="number">1</span>, l, mid, ql, qr)) ;</span><br><span class="line"><span class="keyword">if</span> (qr &gt; mid) res = min(res, querys(rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>, mid + <span class="number">1</span>, r, ql, qr)) ; <span class="keyword">return</span> res ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">work</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> f)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k : query[u]) </span><br><span class="line">Ans[k] = querys(<span class="number">1</span>, <span class="number">1</span>, N, Lr[k], Rr[k]) ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[u] ; k ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">if</span> (to(k) == f) <span class="keyword">continue</span> ;</span><br><span class="line"> update(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>, N, E[k].c), update(<span class="number">1</span>, <span class="number">1</span>, N, to(k), Last[to(k)], -(E[k].c &lt;&lt; <span class="number">1</span>)), </span><br><span class="line">work(to(k), u) ; update(<span class="number">1</span>, <span class="number">1</span>, N, <span class="number">1</span>, N, -E[k].c), update(<span class="number">1</span>, <span class="number">1</span>, N, to(k), Last[to(k)], E[k].c &lt;&lt; <span class="number">1</span>) ; </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">2</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%I64d"</span>, &amp;A, &amp;B), Add(A, i, B) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;q, &amp;Lr[i], &amp;Rr[i]), query[q].push_back(i) ; </span><br><span class="line">dfs(<span class="number">1</span>, <span class="number">0</span>) ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (i != Last[i]) dis[i] = Inf ; build(<span class="number">1</span>, <span class="number">1</span>, N) ; <span class="comment">// by _pks</span></span><br><span class="line">work(<span class="number">1</span>, <span class="number">0</span>) ; <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="built_in">printf</span>(<span class="string">"%I64d\n"</span>, Ans[i]) ; <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// by _pks by _pks by _pks by_pks</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>by_pks其实是用来占位的因为我喜欢同一个代码块里，每一行的长度都是递增的XD</del></p><h1 id="G"><a href="#G" class="headerlink" title="$G$"></a>$G$</h1><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89-darkviolet.svg" alt></p><p>题目大意：给出一棵N个点的树，初始时某些节点是白色，其他节点没有颜色，有两个人在树上博弈。每一回合，一方可以将一个没有颜色的点染成白色，然后另一方可以将一个没有颜色的点染成黑色。如果在某次染色后树上存在三个点ABC满足有边$(A,B)(B,C)$且ABC都有颜色且颜色相同，则该颜色对应的人获胜。假设两人绝顶聪明，问最后结果如何。$T\leq 5e5,\sum n\leq 5e5$</p><p>emmmm一道我不会的题。其实总觉得这种博弈论有一种一脉相承的精妙之处，但是自己总是不能稔熟于心……GG</p><p>然后我选择搬了<code>Itst</code>巨佬的思路过来</p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><p>首先我们考虑，黑色是不可能获胜的，毕竟原来就已经有一堆白点了……</p><p>其次我们考虑先忽略原树中的所有已经被染过色的点，然后用一种比较前卫的方式来分类讨论——<code>度数讨论法</code>。</p><ul><li>假设有一个点的度数$\geq 4$，换句话说这个联通块的点的个数要$\geq 5$，那么根据白色先手的原则，白色的一定可以取$3$个节点，并且一定可以取$3$个连续的节点。所以白色赢；</li><li>如果存在一个点的度数$=3$，且它所连的$3$个点至少有$2$个点不是叶子节点，那么我们如果考虑讲树平展开之后，先选中间的点，就可以保证白色赢；</li><li>其余的情况我们可以考虑大力分类讨论树的形态：<img src="1.png" alt></li></ul><p>我们发现，对于前两种情况都是draw的。而对于第三种情况，如果总点数是<strong>奇数个</strong>，那么<strong>白色必赢</strong>。我们考虑从左向右染色，白色第一次考虑染从左往右第二个非叶子节点，那么黑色只能染第一个；白色染第四个，黑色只能染第三个……以此类推。到最后一定会出现白色染了$2n$这个点，黑色去染$2n-1$这个点，那么白色接下来就可以染$2n+1$这个点，Winner！</p><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><p>接下来我们如果要算上原本就是白色的点呢？对于这种情况，一般都是转化回我们已经讨论完的<code>0x01</code>去。我们考虑把一个白色点拆成$4$个无色点。<img src="2.png" alt></p><p>其中A就是原来的$1$号点，原图上哪些点跟$1$连了边，现在也和$A$连，换句话说就是$A$多了一棵三个节点的子树。那么接下来我们考虑其可行性。</p><ul><li>如果$A$被染成黑色，那么白色没有必要再染子树内的点，这种情况等价于不连子树。</li><li>如果$A$被染成白色，那么黑色一定要染$B$点，那么此时这棵子树又没用了，所以也等价于不连子树。</li></ul><p>嗯，然后这个题就完了。我们可以发现就是一个大力分类讨论的过程——题还是挺好的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 500020</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to(k) E[k].to</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> Input[MAXN] ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next ;</span><br><span class="line">&#125;E[MAXN &lt;&lt; <span class="number">1</span>] ; <span class="keyword">int</span> In[MAXN], qaq ;</span><br><span class="line"><span class="keyword">int</span> T, N, head[MAXN], A, qwq, B, i, j, ans, cnt ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">int</span> u, <span class="keyword">int</span> v)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, In[v] ++ ;</span><br><span class="line">E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, In[u] ++ ; </span><br><span class="line">E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; T ;</span><br><span class="line"><span class="keyword">while</span> (T --)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;N), ++qwq ;</span><br><span class="line">fill(In, In + N + <span class="number">4</span>, <span class="number">0</span>) ;</span><br><span class="line">fill(head, head + N + <span class="number">4</span>, <span class="number">0</span>), ans = <span class="number">0</span>, qaq = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt; N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;A, &amp;B), Add(A, B) ;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%s"</span>, Input) ; <span class="keyword">if</span> (N &lt; <span class="number">3</span>) <span class="built_in">puts</span>(<span class="string">"Draw"</span>) ; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (N == <span class="number">3</span>)&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i) ans += Input[i] == <span class="string">'W'</span> ;</span><br><span class="line"><span class="built_in">puts</span>(ans &gt;= <span class="number">2</span> ? <span class="string">"White"</span> : <span class="string">"Draw"</span>) ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> Linshi = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt; N ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (Input[i] == <span class="string">'W'</span>)&#123;</span><br><span class="line">head[++ N] = <span class="number">0</span>, Add(i + <span class="number">1</span>, N), In[N] = <span class="number">3</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N &amp;&amp; ans &lt;= <span class="number">0</span>; ++ i)&#123;</span><br><span class="line"><span class="keyword">if</span> (In[i] &gt; <span class="number">3</span>) ans ++ ;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (In[i] == <span class="number">3</span>)&#123; Linshi = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = head[i] ; j ; j = E[j].next) Linshi += (In[to(j)] &gt;= <span class="number">2</span>) ;</span><br><span class="line">ans += Linshi &gt; <span class="number">1</span>, qaq ++ ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (qaq == <span class="number">2</span> &amp;&amp; (N % <span class="number">2</span>)) ans ++ ; <span class="built_in">puts</span>(ans ? <span class="string">"White"</span> : <span class="string">"Draw"</span>) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// if (qwq == 20) return 0 ;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>Global Round的题目质量不低蛤。</p>]]></content>
    
    <summary type="html">
    
      2019年2月7日举办的一场CF，$\text{div1+div2}$，题目质量较高。
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="Codeforces" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/Codeforces/"/>
    
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/tags/%E9%A2%98%E8%A7%A3/"/>
    
      <category term="树模型" scheme="https://Flower233pks.github.io/blog/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="动态规划-普通DP" scheme="https://Flower233pks.github.io/blog/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E6%99%AE%E9%80%9ADP/"/>
    
      <category term="CodeForces" scheme="https://Flower233pks.github.io/blog/tags/CodeForces/"/>
    
      <category term="思维题/构造" scheme="https://Flower233pks.github.io/blog/tags/%E6%80%9D%E7%BB%B4%E9%A2%98-%E6%9E%84%E9%80%A0/"/>
    
  </entry>
  
  <entry>
    <title>主席树上的不靠谱解法</title>
    <link href="https://Flower233pks.github.io/blog/2019/04/05/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%C2%B7%E4%B8%8D%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%81%9A%E6%B3%95%E2%80%94%E2%80%94%E4%B8%BB%E5%B8%AD%E6%A0%91%E4%B8%8A%E4%BA%8C%E5%88%86/"/>
    <id>https://Flower233pks.github.io/blog/2019/04/05/可持久化数据结构·不靠谱的做法——主席树上二分/</id>
    <published>2019-04-05T12:56:38.000Z</published>
    <updated>2019-05-18T06:59:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-0x00-Preface"><a href="#rm-0x00-Preface" class="headerlink" title="$\rm{0x00~}Preface$"></a>$\rm{0x00~}Preface$</h1><p>某天机房里，<del>公认的ezi</del> lwy跟wxl随口说了一道luogu上的题，wxl来了兴趣，被pks听见了，于是pks就瞅了一眼这题，然后说了一句”这不就是sb主席树上二分吗？随便一个$\Theta(n \log^2n)$就可以过啊”</p><p>然后pks那一整个晚上都在搞这个假算法，$\rm{QAQ}$</p><p>于是就有了本文，整理了两道主席树的正确（？）应用。</p><h1 id="rm-0x01-faebdc的烦恼"><a href="#rm-0x01-faebdc的烦恼" class="headerlink" title="$\rm{0x01~}$faebdc的烦恼"></a>$\rm{0x01~}$faebdc的烦恼</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P1997" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P1997</a></p><p>呃，其实这不是一道很难的题。因为本来就保证了数列不降，所以我们直接记录一下每个数出现区间的左右端点，瞎搞就好。但是既然我说了要主席树上二分，就一定要写写看吧qaq</p><p>我们考虑在我的<a href>这篇博客</a>里面曾经介绍过的$T3$中的算法，我们直接去查询左右儿子值域区间内中数的个数，看看哪个可行，然后暴力找就好。</p><p>但是…他TLE了两个点，因为我是这么写的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; </span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (sum[Right] - sum[Left] &lt; k) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt;= k) </span><br><span class="line">        <span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ; </span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>),Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>), </span><br><span class="line">  T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N; i ++) </span><br><span class="line">      pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, </span><br><span class="line">  T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;a, &amp;b) ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           <span class="keyword">register</span> <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid) &gt; <span class="number">0</span>) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好像很正常？但是，这个复杂度是完全错误的。最大的时候甚至可以到达单次$m \log n$的复杂度——注意是单次。因为我们每次询问的时候，如果查询了左区间不合法，那么不代表右区间合法——毕竟是二分里的<code>check</code>环节。而上一个类似方法的题，可以保证我们如果左区间的数的出现次数不超过$\frac{1}{2}$，那么右区间一定满足——但显然的是，本题不具有这个性质。</p><p>所以，总结一下，主席树上不可以二分。</p><p>但是如果我们加一点剪枝呢？</p><p>我们考虑，对于主席树上的每一个点维护一个$maxx$一个$minx$，记录区间内<strong>单个数值出现的最大次数和最小次数</strong>，那么我们在$check$的时候就可以直接用这种方式判——如果$r$版本的主席树内出现的最大次数减去$l-1$版本内出现的数的最小次数$k&lt;q$（$q$是二分出的$val$），那么一定不满足。</p><p>比较显然的是，这不是一种最优性剪枝，而是一种可行性剪枝。但是对付这道题却有着不错的效果，跑的奇快。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> il inline</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADD 393216</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rr register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 100073</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ;</span><br><span class="line"><span class="keyword">int</span> a, b, c, pos, N, base[MAXN], mx[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], mn[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], aft[MAXN], M, i ;</span><br><span class="line"><span class="keyword">int</span> cnt, Len, T[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], L[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], R[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>], sum[(MAXN &lt;&lt; <span class="number">5</span>) + <span class="number">1</span>] ;</span><br><span class="line"></span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">qr</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> k = <span class="number">0</span>, f = <span class="number">1</span> ; <span class="keyword">char</span> c = getchar() ;</span><br><span class="line">    <span class="keyword">while</span>(!<span class="built_in">isdigit</span>(c))&#123; <span class="keyword">if</span> (c == <span class="string">'-'</span>) f = <span class="number">-1</span> ; c = getchar() ; &#125;</span><br><span class="line">    <span class="keyword">while</span>(<span class="built_in">isdigit</span>(c)) k = (k &lt;&lt; <span class="number">1</span>) + (k &lt;&lt; <span class="number">3</span>) + c - <span class="number">48</span>, c = getchar() ;</span><br><span class="line">    <span class="keyword">return</span> k * f ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;last, <span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">register</span> <span class="keyword">int</span> rt = ++ cnt, mid ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span>, R[rt] = R[last], L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">    mx[rt] = mn[rt] = sum[rt] ; </span><br><span class="line">        <span class="keyword">return</span> rt ;</span><br><span class="line">    &#125;</span><br><span class="line">    mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">    <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    mn[rt] = min(mn[L[rt]], mn[R[rt]]), mx[rt] = max(mx[L[rt]], mx[R[rt]]) ;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">query</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;Left,<span class="keyword">const</span> <span class="keyword">int</span> &amp;Right,<span class="keyword">const</span> <span class="keyword">int</span> &amp;l, <span class="keyword">const</span> <span class="keyword">int</span> &amp;r, <span class="keyword">const</span> <span class="keyword">int</span> &amp;k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">1</span> ; rr <span class="keyword">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>, qwq ;</span><br><span class="line">    <span class="keyword">if</span> (mx[L[Right]] - mn[L[Left]] &gt;= k &amp;&amp; query(L[Left], L[Right], l, mid, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">if</span> (mx[R[Right]] - mn[R[Left]] &gt;= k &amp;&amp; query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M; <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i)  base[i] = qr() + ADD, aft[i] = base[i] ;</span><br><span class="line">    sort (aft + <span class="number">1</span>, aft + N + <span class="number">1</span>), Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= N ; ++ i) pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft, T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= M ; ++ i)&#123;</span><br><span class="line">        a = qr(), b = qr() ;</span><br><span class="line">        <span class="keyword">register</span> <span class="keyword">int</span> l = <span class="number">1</span>, mid, r = b - a + <span class="number">1</span>, ans = <span class="number">1</span> ;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">           mid = (l + r) &gt;&gt; <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">if</span> (query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, mid)) ans = mid, l = mid + <span class="number">1</span> ; </span><br><span class="line">            <span class="keyword">else</span> r = mid - <span class="number">1</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, ans) ;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-0x02-CF840D-Destiny"><a href="#rm-0x02-CF840D-Destiny" class="headerlink" title="$\rm{0x02~}CF840D~Destiny$"></a>$\rm{0x02~}CF840D~Destiny$</h2><p>传送门：<a href="http://codeforces.com/problemset/problem/840/D" target="_blank" rel="noopener">http://codeforces.com/problemset/problem/840/D</a></p><p>简化版题意：每次给出三个参数$l,r,k$，询问区间$[l,r]$内是否存在出现次数严格大于$\frac{r-l+1}{k}$的数。如果存在就输出最小的那个$ans$，否则输出$-1$.</p><p>这个东西……就直接查询就好了啊……由于不用二分，所以复杂度相对来说稳定了一些。于是我就没有加上文中提到过的那个诡异的优化。我们每次先查左半边，就可以保证在值域上最小，也就是说每次我们都可以求出最小的合法$ans$了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">build</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = <span class="number">0</span> ;</span><br><span class="line">    <span class="keyword">if</span>(l &lt; r)&#123;</span><br><span class="line">        L[rt] = build(l, mid) ;</span><br><span class="line">        R[rt] = build(mid + <span class="number">1</span>, r) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> last, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> rt = ++ cnt ;</span><br><span class="line">    sum[rt] = sum[last] + <span class="number">1</span> ;</span><br><span class="line">    R[rt] = R[last] ;</span><br><span class="line">    L[rt] = L[last] ;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt;= mid) L[rt] = update(L[last], l, mid, x) ;</span><br><span class="line">        <span class="keyword">else</span>  R[rt] = update(R[last], mid + <span class="number">1</span>, r, x) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">il <span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> Left, <span class="keyword">int</span> Right, <span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> aft[l] ; <span class="keyword">int</span> qwq ;</span><br><span class="line">    <span class="comment">// if (sum[Right] - sum[Left] &lt;= k) return -1 ;</span></span><br><span class="line">    <span class="keyword">int</span> x = sum[L[Right]] - sum[L[Left]], y = sum[R[Right]] - sum[R[Left]] ;</span><br><span class="line">    <span class="keyword">if</span> (x &gt; k) </span><br><span class="line"><span class="keyword">if</span> ((qwq = query(L[Left], L[Right], l, mid, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">if</span> (y &gt; k) </span><br><span class="line"><span class="keyword">if</span> ((qwq = query(R[Left], R[Right], mid + <span class="number">1</span>, r, k)) &gt; <span class="number">0</span>) <span class="keyword">return</span> qwq ;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++) base[i] = qr(), aft[i] = base[i] ;</span><br><span class="line">    sort(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) ;</span><br><span class="line">    Len = unique(aft + <span class="number">1</span>, aft + N + <span class="number">1</span>) - (aft + <span class="number">1</span>) ; </span><br><span class="line">    T[<span class="number">0</span>] = build(<span class="number">1</span>, Len) ;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= N; i ++)&#123;</span><br><span class="line">        pos = lower_bound(aft + <span class="number">1</span>, aft + Len + <span class="number">1</span>, base[i]) - aft;</span><br><span class="line">        T[i] = update(T[i - <span class="number">1</span>], <span class="number">1</span>, Len, pos) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>; i &lt;= M; i ++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;a, &amp;b, &amp;c) ; <span class="keyword">int</span> k = (b - a + <span class="number">1</span>) / c ;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; query(T[a - <span class="number">1</span>], T[b], <span class="number">1</span>, Len, k) &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span> ; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事实上，加上那优化之后，总用时大约$27000ms$，而我这个不加优化的版本足足跑了$56677ms$……真丢人啊</p>]]></content>
    
    <summary type="html">
    
      yy出来的假复杂度做法，但是据说有一个很强的剪枝？
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="可持久化/可持久化线段树" scheme="https://Flower233pks.github.io/blog/tags/%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96-%E5%8F%AF%E6%8C%81%E4%B9%85%E5%8C%96%E7%BA%BF%E6%AE%B5%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>防守战线[ZJOI2013] &amp; 志愿者招募[NOI2008]</title>
    <link href="https://Flower233pks.github.io/blog/2019/04/05/fszx-and-zyzzm/"/>
    <id>https://Flower233pks.github.io/blog/2019/04/05/fszx-and-zyzzm/</id>
    <published>2019-04-05T09:28:46.000Z</published>
    <updated>2019-05-18T06:59:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="rm-0x01-ZJOI2013-防守阵线"><a href="#rm-0x01-ZJOI2013-防守阵线" class="headerlink" title="$\rm{0x01}$ [ZJOI2013]防守阵线"></a>$\rm{0x01}$ [ZJOI2013]防守阵线</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3337" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3337</a></p><p>首先就是要明白怎么建模，大概就是：</p><p>$$<br>\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots n)\\\<br>\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} x_{j} \geq d_i \quad (i = 1,2,3\cdots m)<br>$$</p><p>其中$x_j$表示$j$这个地方有几座塔。</p><p>那我们首先把它对偶过去，就会得到：<br>$$<br>\text{最大化} \quad \sum d_iy_i \quad(i = 1, 2,3 \cdots m) \\\<br>\text{满足约束} \quad \sum \limits_{j=l_i}^{r_i} y_{j} \leq c_i\quad (i = 1,2,3\cdots n)<br>$$<br>然后我们考虑，似乎价值不能带小数啊，毕竟题目中规定了价值都为整数<del>(事实上并没有规定但是数据是这样给的)</del>，换句话说我们不能存在建某座塔的一部分(比如只建一半)。</p><p>那么这就是<strong>整数线性规划问题</strong>，换句话说就是<strong>自变量取值范围是$\Z$的线性规划</strong>。</p><p>呃，这问题已经被证明是$\rm{NP-Hard}$的问题了…但是，有一种矩阵叫做<strong>全幺模矩阵</strong>，即<strong>元素只会是$\boldsymbol{0,1,-1}$的矩阵</strong>，被证明肯定至少有一组最优解保证整数线性规划与实数线性规划的方案一致。</p><p><del>啥，你说啥？你要关于全幺模矩阵这个性质的争鸣？是百家争鸣那个争鸣吗？学OI呢别瞎讨论历史</del> </p><p>然后就可以一发单纯形给艹过去啦~开心心~</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span>, INF = <span class="number">1e9</span> ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">double</span> A[MAXN][MAXM] ;</span><br><span class="line"><span class="keyword">int</span> N, M, B, E, i, j, k, p ; <span class="keyword">double</span> res, t, cost[MAXM], _need[MAXM] ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> e, <span class="keyword">int</span> l)</span></span>&#123;</span><br><span class="line">cost[l] /= A[l][e], t = A[l][e], A[l][e] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) A[l][i] /= t ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">if</span> (i != l &amp;&amp; <span class="built_in">abs</span>(A[i][e]) &gt; eps)&#123;</span><br><span class="line">cost[i] -= A[i][e] * cost[l] ;  </span><br><span class="line"><span class="keyword">for</span> (p = <span class="number">1</span> ; p &lt;= M ; ++ p) <span class="keyword">if</span> (p != e) A[i][p] -= A[i][e] * A[l][p] ;</span><br><span class="line">A[i][e] = - A[i][e] * A[l][e] ;</span><br><span class="line">&#125; </span><br><span class="line">res += _need[e] * cost[l] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (i != e) _need[i] -= _need[e] * A[l][i] ;</span><br><span class="line">_need[e] = - _need[e] * A[l][e] ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)&#123;</span><br><span class="line"><span class="keyword">double</span> MINX = INF ; j = <span class="number">0</span>, k = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= M ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="keyword">if</span> (j &gt; M) <span class="keyword">return</span> res ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MINX &gt; cost[i] / A[i][j]) k = i, MINX = cost[i] / A[i][j] ;</span><br><span class="line"><span class="keyword">if</span> (MINX &gt;= INF) <span class="keyword">return</span> INF ;  Pivot(j, k) ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%lf"</span>, &amp;cost[i]) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;B, &amp;E, &amp;_need[i]) ; <span class="comment">//约束 </span></span><br><span class="line"><span class="keyword">for</span> (j = B ; j &lt;= E ; ++ j) A[j][i] = <span class="number">1.0</span> ;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex() + <span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么说呢，似乎单纯形有好多地方的写法都比较灵活<del>让我不知道背什么样的板子会更好</del></p><h1 id="rm-0x02-NOI2008-志愿者招募"><a href="#rm-0x02-NOI2008-志愿者招募" class="headerlink" title="$\rm{0x02}$ [NOI2008] 志愿者招募"></a>$\rm{0x02}$ [NOI2008] 志愿者招募</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P3980" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P3980</a></p><p><del>什么鬼啊这不是上面的那道题吗</del></p><p>还是：<br>$$<br>\text{最小化} \quad \sum c_ix_i \quad(i = 1,2,3\cdots m)\\\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \geq A_i \quad (i = 1,2,3\cdots n)<br>$$<br>其中$x_j$表示选择的第$j$类志愿者的个数，$w_{i,j}$表示在第$i$天，第$j$类志愿者能否选择。那么还是老样子，对偶过去就可以得到：<br>$$<br>\text{最大化} \quad \sum A_ix_i \quad(i = 1,2,3\cdots n)\\\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} w_{i,j}x_{j} \leq c_i \quad (i = 1,2,3\cdots m)<br>$$<br>怎么说呢……这个一开始的建模比上一个题还是有难度的，因为上一个题的$L_i,R_i$跟约束有关，而这次的$L_i,R_i$则是跟目标函数有关——或许不应该这么说，但是看上去确实不如上面那题跟约束有关系就对了<del>(我在BB一堆什么啊)</del></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INF 1e9</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXN 1035</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXM 10010</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> eps = <span class="number">1e-8</span> ; <span class="keyword">double</span> res ;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span> ; <span class="keyword">int</span> b[MAXM], e[MAXM] ; </span><br><span class="line"><span class="keyword">int</span> N, M, i, j, k ; <span class="keyword">double</span> C[MAXM], _need[MAXM], A[MAXM][MAXN] ; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Pivot</span><span class="params">(<span class="keyword">int</span> posN, <span class="keyword">int</span> posC)</span></span>&#123;</span><br><span class="line">C[posC] /= A[posC][posN] ; <span class="comment">// constraint divided by A_&#123;l,e&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) A[posC][p] /= A[posC][posN] ;<span class="comment">//this line Booom</span></span><br><span class="line">A[posC][posN] = <span class="number">1</span> ;</span><br><span class="line"><span class="comment">// Pivot is above, taking it back is below</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= M ; ++ p)<span class="comment">//taking back to constraints </span></span><br><span class="line"><span class="keyword">if</span> (p != posC &amp;&amp; <span class="built_in">fabs</span>(A[p][posN]) &gt; eps)&#123;</span><br><span class="line">C[p] -= A[p][posN] * C[posC] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) </span><br><span class="line"><span class="keyword">if</span> (i != posN) A[p][i] -= A[p][posN] * A[posC][i] ;</span><br><span class="line">A[p][posN] = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br><span class="line">res += _need[posN] * C[posC] ;<span class="comment">//this time results in a better INIT-Sol</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">1</span> ; p &lt;= N ; ++ p) <span class="keyword">if</span> (p != posN) _need[p] -= _need[posN] * A[posC][p] ;</span><br><span class="line">_need[posN] = - _need[posN] * A[posC][posN] ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">simplex</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">j = <span class="number">0</span>, k = <span class="number">0</span> ; <span class="keyword">double</span> MAX = INF ;</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt;= N ; ++ j) <span class="keyword">if</span> (_need[j] &gt; eps) <span class="keyword">break</span> ; <span class="comment">/*1*/</span> <span class="keyword">if</span> (j &gt; N) <span class="keyword">return</span> res ; <span class="comment">//make-it-sure if go on</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) <span class="keyword">if</span> (A[i][j] &gt; eps &amp;&amp; MAX &gt; C[i] / A[i][j]) MAX = C[i] / A[i][j], k = i ; <span class="comment">//find the min_val constraint</span></span><br><span class="line"><span class="keyword">if</span> (MAX &gt;= INF) <span class="keyword">return</span> INF ; <span class="comment">/* this task is unbounded */</span> Pivot(j, k) ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">cin</span> &gt;&gt; _need[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i)&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d%d%lf"</span>, &amp;b[i], &amp;e[i], &amp;C[i]) ;</span><br><span class="line"><span class="keyword">for</span> (j = b[i] ; j &lt;= e[i] ; ++ j) A[i][j] = <span class="number">1</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, (<span class="keyword">int</span>)(simplex()+<span class="number">0.5</span>)) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :$Candy?$的$blog$ <a href="https://www.cnblogs.com/candy99/" target="_blank" rel="noopener">$^{^{[\nearrow ]}}$</a></li></ul>]]></content>
    
    <summary type="html">
    
      【[ZJOI2013]防守阵线】：战线可以看作一个长度为$n$的序列，现在需要在这个序列上建塔来防守敌兵，在序列第$i$号位置上建一座塔有$C_i$的花费，且一个位置可以建任意多的塔，费用累加计算。有$m$个区间$[L1,R1],[L2,R2],\cdots,[L_m,R_m]$，在第$i$个区间的范围内要建至少$D_i$座塔。求最少花费。
    
    </summary>
    
      <category term="题解" scheme="https://Flower233pks.github.io/blog/categories/%E9%A2%98%E8%A7%A3/"/>
    
    
      <category term="线性规划/单纯形法" scheme="https://Flower233pks.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/"/>
    
      <category term="线性规划/对偶定理" scheme="https://Flower233pks.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>网络流24题专题1·较简单的费用流</title>
    <link href="https://Flower233pks.github.io/blog/2019/03/29/nw-flow-24-1/"/>
    <id>https://Flower233pks.github.io/blog/2019/03/29/nw-flow-24-1/</id>
    <published>2019-03-29T13:43:58.000Z</published>
    <updated>2019-05-18T10:14:30.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p><h1 id="rm-Preface"><a href="#rm-Preface" class="headerlink" title="$\rm{Preface}~$"></a>$\rm{Preface}~$</h1><p>关于网络流，一直是我的一个阴影……因为去年暑假，大家都会而网络流，我因为觉得这个算法没意思就没学，结果rqy来给我们考试网络流那题被全场打爆了——除了我qaq。</p><p>于是决定开始做这些题，每道题都会标注我看题解程度多少，如果太高的话会被自己嫌弃的qaq……希望自己能争气一点。</p><h1 id="rm-0x01-运输问题"><a href="#rm-0x01-运输问题" class="headerlink" title="$\rm{0x01}$ 运输问题"></a>$\rm{0x01}$ 运输问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4015" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4015</a></p><p>看了，程度大概80%……呃我知道这个题不难，但是毕竟我上次写费用流可是几百年之前了啊……qaq</p><p>其实就是<br>$$<br>S\stackrel{f = a_i,c = 0}{\longrightarrow}i \stackrel{f = Inf,c = c_{i,j}}{\longrightarrow}j \stackrel{f = b_j,c=0}{\longrightarrow}T<br>$$</p><p>其中$i$代表仓库的编号，$j$代表商店的编号，建完图跑费用流即可。</p><p>由于SPFA死了，所以就一直用$dijk$做费用流，只不过难背一点……然后第二问的话就把权值取负重新做一下费用流就好。</p><p>总结一下，这个题似乎是比较裸的费用流的题了？一般费用流大概都是用来求解最优化问题的吧qwq……</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Edge</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> to, next, f, c ;</span><br><span class="line">&#125;E[MAXN] ; <span class="keyword">int</span> head[MAXN], cnt = <span class="number">-1</span> ;</span><br><span class="line"><span class="keyword">int</span> S, T, N, M, dist[MAXN], i, j, k, t[MAXN], x ; </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> dist, num ;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span> &lt;(<span class="keyword">const</span> node &amp; now) <span class="keyword">const</span>&#123;<span class="keyword">return</span> dist &gt; now.dist ; &#125;</span><br><span class="line">&#125;; priority_queue&lt;node&gt; q ; <span class="keyword">bool</span> vis[MAXN] ; <span class="keyword">int</span> Last[MAXN], F[MAXN], H[MAXN], Pre[MAXN], MAX_C ;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp;u, <span class="keyword">const</span> <span class="keyword">int</span> &amp;v, <span class="keyword">const</span> <span class="keyword">int</span> &amp;f, <span class="keyword">const</span> <span class="keyword">int</span>&amp; c)</span></span>&#123;</span><br><span class="line">E[++ cnt].to = v, E[cnt].c = c, t[cnt] = f ;</span><br><span class="line">E[cnt].f = f, E[cnt].next = head[u], head[u] = cnt ;</span><br><span class="line">E[++ cnt].to = u, E[cnt].c = -c, t[cnt] = <span class="number">0</span> ;</span><br><span class="line">E[cnt].f = <span class="number">0</span>, E[cnt].next = head[v], head[v] = cnt ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijkstra</span><span class="params">()</span></span>&#123;</span><br><span class="line">    q.push((node)&#123;<span class="number">0</span>, S&#125;) ; vis[S] = dist[S] = <span class="number">0</span>, F[<span class="number">0</span>] = Inf ;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= T ; ++ i) dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">node now = q.top() ; q.pop() ;</span><br><span class="line"><span class="keyword">int</span> fr = now.num, sec = now.dist ; <span class="keyword">if</span> (vis[fr]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">for</span> (vis[fr] = <span class="number">1</span>, k = head[fr] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">int</span> nowc = sec + E[k].c + H[fr] - H[to(k)] ;</span><br><span class="line"><span class="keyword">if</span> (E[k].f &gt; <span class="number">0</span> &amp;&amp; !vis[to(k)] &amp;&amp; dist[to(k)] &gt; nowc)&#123;</span><br><span class="line">dist[to(k)] = nowc, q.push((node)&#123;dist[to(k)], to(k)&#125;) ;</span><br><span class="line">F[to(k)] = min(F[fr], E[k].f), Pre[to(k)] = fr, Last[to(k)] = k ; </span><br><span class="line">&#125;<span class="comment">//!!!!!</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[T] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line"><span class="keyword">while</span>(_Ed != S)E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N &gt;&gt; M, S = <span class="number">0</span> ; </span><br><span class="line">T = N + M + <span class="number">1</span>, <span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(S, i, x, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + M ; ++ i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, T, x, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + M ; ++ j)</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;x), Add(i, j, Inf, x) ;</span><br><span class="line"><span class="comment">//    for (i = 0 ; i &lt;= cnt ; ++ i) printf("%d %d %d\n", E[i].to + 1, E[i].f, E[i].c) ;</span></span><br><span class="line">MCMF(<span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i], E[i].c = -E[i].c ; MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x02-分配问题"><a href="#rm-0x02-分配问题" class="headerlink" title="$\rm{0x02~}$ 分配问题"></a>$\rm{0x02~}$ 分配问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4014" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4014</a></p><p>这道题由于实在太水了，所以没有看题解(窃喜</p><p>其实就是建$2n$个点，然后$i \stackrel{f = Inf,c = base_{i,j}}{\longrightarrow} j$就连完了。</p><p>不得不说…建边真的是太水了，太水了，qaq</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">此处是dijkstra……</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MCMF</span><span class="params">(<span class="keyword">int</span> qwq)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> _Ed ; MAX_C = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (dijkstra())&#123;</span><br><span class="line">_Ed = T, MAX_C += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line"><span class="keyword">while</span>(_Ed != S)E[Last[_Ed]].f -= F[T], E[Last[_Ed] ^ <span class="number">1</span>].f += F[T], _Ed = Pre[_Ed] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= T ; ++ i) H[i] += dist[i] ; <span class="comment">/*cout &lt;&lt; MAX_C &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; MAX_C * qwq &lt;&lt; <span class="built_in">endl</span> ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; N ; S = <span class="number">0</span>, T = N &lt;&lt; <span class="number">1</span> | <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i) Add(S, i, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = N + <span class="number">1</span> ; i &lt;= N + N ; ++ i) Add(i, T, <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = N + <span class="number">1</span> ; j &lt;= N + N ; ++ j)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x, Add(i, j, Inf, x) ;</span><br><span class="line">MCMF(<span class="number">1</span>) ; <span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].c = -E[i].c, E[i].f = t[i] ; MCMF(<span class="number">-1</span>) ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rm-0x03-数字梯形问题"><a href="#rm-0x03-数字梯形问题" class="headerlink" title="$\rm{0x03}~$数字梯形问题"></a>$\rm{0x03}~$数字梯形问题</h1><p>传送门：<a href="https://www.luogu.org/problemnew/show/P4013" target="_blank" rel="noopener">https://www.luogu.org/problemnew/show/P4013</a></p><p>看题解：$90\%$+…我是真没见过这种建边方式啊喂，并且我一开始建的边很迷…我没有看到，呃，换句话说，我看到了然后忘了，一个数只能向正下方和右下方走……</p><h2 id="第一问·完全不相交的路径"><a href="#第一问·完全不相交的路径" class="headerlink" title="第一问·完全不相交的路径"></a>第一问·完全不相交的路径</h2><p>我真是要菜死了，题解里面说”拆点已经是烂大街的$trick$了”，我：？？？</p><p>大概就是每个点拆成两个点，原因是我们需要<strong>把点上的限制转化成边上的限制</strong>，所以需要进行拆点，然后对于某个点和它的副本连一条$f=1,c=-base[x]$的边，毕竟是求最大值。然后$S$和最顶上的连$f=1,c=0$的边，$T$和最下面一层连$f=1,c=0$，就完了。</p><h2 id="第二问-·-边不相交的路径"><a href="#第二问-·-边不相交的路径" class="headerlink" title="第二问 · 边不相交的路径"></a>第二问 · 边不相交的路径</h2><p>我们考虑此时其实是删除了点的限制，那么我们就将每个点和自己的副本之间的边容量改成$Inf$，并把$T$与最底下的所有点的容量扩为$Inf$即可。注意后半部分的扩容，其目的在于防止中间节点的扩容被限制。</p><h2 id="第三问-·-随便的路径"><a href="#第三问-·-随便的路径" class="headerlink" title="第三问 · 随便的路径"></a>第三问 · 随便的路径</h2><p>既然都随便了，就直接把所有的边都设置成$Inf$，但是显然的是我们不能扩$S$连出去的边。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">dijk</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= tot + <span class="number">2</span> ; ++ i) </span><br><span class="line">dist[i] = F[i] = Inf, vis[i] = <span class="number">0</span> ;</span><br><span class="line">dist[S] = <span class="number">0</span>, q.push((Node)&#123;S, <span class="number">0</span>&#125;) ;</span><br><span class="line"><span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">Node now = q.top() ; q.pop() ;</span><br><span class="line"><span class="keyword">int</span> num = now.num, dis = now.dist ; <span class="keyword">if</span> (vis[num]) <span class="keyword">continue</span> ;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = head[num] ; k != <span class="number">-1</span> ; k = E[k].next)&#123;</span><br><span class="line"><span class="keyword">int</span> DIS = E[k].c + H[num] - H[to(k)] + dis ;</span><br><span class="line"><span class="keyword">if</span> (DIS &lt; dist[to(k)] &amp;&amp; !vis[to(k)] &amp;&amp; E[k].f)</span><br><span class="line">F[to(k)] = min(F[num], E[k].f), dist[to(k)] = DIS, </span><br><span class="line">q.push((Node)&#123;to(k), DIS&#125;), Pre[to(k)] = num, Last[to(k)] = k ;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dist[T] &lt; Inf ;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">MCMF</span><span class="params">()</span></span>&#123;</span><br><span class="line">Ans = <span class="number">0</span> ;</span><br><span class="line"><span class="keyword">while</span> (dijk())&#123;</span><br><span class="line">_End = T, Ans += (dist[T] - H[S] + H[T]) * F[T] ;</span><br><span class="line"><span class="keyword">while</span> (_End) E[Last[_End]].f -= F[_End], E[Last[_End] ^ <span class="number">1</span>].f += F[_End], _End = Pre[_End] ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= tot + <span class="number">2</span> ; ++ i) H[i] += dist[i] ; <span class="comment">/*cout &lt;&lt; -Ans &lt;&lt; endl ;*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> L1, R1, L ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(head, <span class="number">-1</span>, <span class="keyword">sizeof</span>(head)) ;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; M &gt;&gt; N ; S = <span class="number">0</span>, T = <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j) </span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; base[i][j], Id[i][j] = (tot += <span class="number">2</span>) ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= M ; ++ i) Add(S, Id[<span class="number">1</span>][i], <span class="number">1</span>, <span class="number">0</span>) ; L = cnt + <span class="number">1</span> ;</span><br><span class="line"><span class="keyword">for</span> (L1 = cnt + <span class="number">1</span>, i = <span class="number">1</span> ; i &lt;= N + M ; ++ i) Add(Id[N][i] + <span class="number">1</span>, T, <span class="number">1</span>, <span class="number">0</span>) ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line">Add(Id[i][j], Id[i][j] + <span class="number">1</span>, <span class="number">1</span>, -base[i][j]) ; R1 = cnt ;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">1</span> ; i &lt;= N ; ++ i)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">1</span> ; j &lt; M + i ; ++ j)</span><br><span class="line"><span class="keyword">if</span> (i &lt; N) Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j], <span class="number">1</span>, <span class="number">0</span>), Add(Id[i][j] + <span class="number">1</span>, Id[i + <span class="number">1</span>][j + <span class="number">1</span>], <span class="number">1</span>, <span class="number">0</span>) ;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ; </span><br><span class="line"><span class="keyword">for</span> (i = L1 ; i &lt; R1 ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line"><span class="keyword">for</span> (i = L1 + <span class="number">1</span> ; i &lt;= R1 ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ;</span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ;  </span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span> ; i &lt;= cnt ; ++ i) E[i].f = t[i] ;</span><br><span class="line"><span class="keyword">for</span> (i = L ; i &lt; cnt ; i += <span class="number">2</span>) E[i].f = Inf ; </span><br><span class="line"><span class="keyword">for</span> (i = L + <span class="number">1</span> ; i &lt;= cnt ; i += <span class="number">2</span>) E[i].f = <span class="number">0</span> ; </span><br><span class="line">MCMF() ; <span class="built_in">cout</span> &lt;&lt; -Ans &lt;&lt; <span class="built_in">endl</span> ; <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"><span class="comment">/*  以下是错误的建边 </span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt;= M ; ++ i) </span></span><br><span class="line"><span class="comment">cin &gt;&gt; base[++ tot], Add(S, tot, 1, -base[tot]) ;</span></span><br><span class="line"><span class="comment">for (i = 1 ; i &lt; N ; ++ i)</span></span><br><span class="line"><span class="comment">for (j = 1 ; j &lt;= M + i ; ++ j)&#123;</span></span><br><span class="line"><span class="comment">cin &gt;&gt; base[++ tot] ; int sd = (2 * M + i - 2) * (i - 1) / 2 + 1 ;</span></span><br><span class="line"><span class="comment">for (int k = sd ; k &lt;= (2 * M + i - 1) * i / 2 ; ++ k) Add(k, tot, Inf, -base[tot]) ;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">for (T = tot + 1, i = tot - (N + M - 1) + 1 ; i &lt;= tot ; ++ i) Add(i, T, 1, 0) ; ++ tot, MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line"><span class="comment">/*MCMF() ; cout &lt;&lt; -Ans &lt;&lt; endl ;  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>嗯，大概这三个题就先分成一组吧！</p>]]></content>
    
    <summary type="html">
    
      主要包括三个问题：运输问题，分配问题和数字梯形问题。
    
    </summary>
    
      <category term="网络流二十四题" scheme="https://Flower233pks.github.io/blog/categories/%E7%BD%91%E7%BB%9C%E6%B5%81%E4%BA%8C%E5%8D%81%E5%9B%9B%E9%A2%98/"/>
    
    
      <category term="网络流24题" scheme="https://Flower233pks.github.io/blog/tags/%E7%BD%91%E7%BB%9C%E6%B5%8124%E9%A2%98/"/>
    
      <category term="费用流/最小费用流" scheme="https://Flower233pks.github.io/blog/tags/%E8%B4%B9%E7%94%A8%E6%B5%81-%E6%9C%80%E5%B0%8F%E8%B4%B9%E7%94%A8%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>随想七·言叶之庭</title>
    <link href="https://Flower233pks.github.io/blog/2019/03/28/%E9%9A%8F%E6%83%B3%E4%B8%83%C2%B7%E8%A8%80%E5%8F%B6%E4%B9%8B%E5%BA%AD/"/>
    <id>https://Flower233pks.github.io/blog/2019/03/28/随想七·言叶之庭/</id>
    <published>2019-03-28T13:32:12.000Z</published>
    <updated>2019-05-18T07:01:32.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>​    Hello darkness my old friend. 黯淡如旧，今时重逢。<br>​    I’ve come to talk with you again. 阔别久日，可赴低叙？<br>​    Because a vision softly creeping. 如梦如幻，于我心萦。<br>​    Left its seeds while I was sleeping. 遗之入梦，齐我心同。<br>​    And the vision that was planted in my brain. 不知归处，不知归处。<br>​    Still remains with the sound of silence. 行舟如风，遣舟迟暮。<br>​    In restless dreams I walk alone. 吾心独行，兰皋止息。<br>​    Narrow streets of cobble stone. 越陌度阡，可有一醉？<br>​    Beneath the hallo of a street lamp’, 如光化影，于我心寂。<br>​    I turned my collar to the cold and damp. 浊寒入襟，刺我心底。<br>​    When my eyes were stabbled. 所见皆幻，所见皆明。<br>​    By the flash of a neon light. 万物皆虚，万物皆允。<br>​    That split the night. 不知归处，不知归处。<br>​    And touched the sound of silence 星瀚灿漫，行人慢走。</p><p>​    ——『$\rm{The ~Sound~of~Silence}$』寂静之声</p></blockquote><p>随想系列目次表：<a href="http://www.orchidany.cf/2050/12/31/%E9%9A%8F%E6%83%B3%C2%B7%E7%9B%AE%E6%AC%A1%E8%A1%A8/" target="_blank" rel="noopener">戳我</a></p><p>这次大概会写的时间线很跳跃，但我真的是被这个故事叩击了心脏最深处的地方。</p><hr><h1 id="rm-Part-1"><a href="#rm-Part-1" class="headerlink" title="$\rm{Part~1}$"></a>$\rm{Part~1}$</h1><p>月考结束了。我终于有时间把这本书读完。</p><p>之前是一次周末，固定的奥赛时间。中途课件去学校的书店逛——一个不错的书吧，书墨香透着小资情调。</p><p>我在不起眼的地方，偶然发现了一本《言叶之庭》——看起来是最后一本了，想都没想就买了。38元，不便宜，薄薄的一本，但是封面却是一片令人赏心悦目的浓绿——是用油彩画的树叶，很漂亮——遂觉得不算物不抵价。</p><p>但买回来才发现，不是新海诚的写的，而是他的一个“好基友”加纳新太，站在秋月孝雄的立场写的。剧情大体上跟我一年之前看过的46分钟的短片差不多，“就当买了收藏吧”我想。</p><p>《言叶之庭》是我去年刚来实验部的时候接触的新鲜东西之一——初中时只懵懂地看过《你的名字》，被里面超越时空的爱情吸引的不要不要的。当时看完确实觉得是部好片，因为剧情很吸引人——当然，大多数都是我的主观感情在起作用，因为当时懵懂的我正好迫切地渴望一次说走就走的爱情。</p><p>那本薄薄的书又带我回想起了第一次看《言叶之庭》时的满足和愉悦，于是便决定买新海诚的原版来看。我并不认为新海诚的原版会比加版或动画版好多少，毕竟故事就是那么个故事，无非是视角不一样罢了。</p><p>并且我也觉得，似乎加版和电影版刻画的人物都太单薄了？反正我在看完加版之后，又重看了一遍电影版，发现不光人物好几处画崩了，有些东西写的似乎太少——不只是意犹未尽了，更像是连说都没说完。所以我一直期待着能够赶紧月考完，好让我在老师忙于讲题+阅卷、没空布置作业的时候，有空看一下新海诚的原版——原版是月考前的大休来的货，书封的主色调是白色的，封1是一张动画电影里的截图——一只睡莲，躺在下着雨的河里。</p><p>或许那时我还不知道，我将会看到一个怎样完整、优秀、细腻的故事——电影和加版，和原版比起来，简直贻笑大方。</p><h1 id="rm-Part-2"><a href="#rm-Part-2" class="headerlink" title="$\rm{Part~2}$"></a>$\rm{Part~2}$</h1><p>感动，满足，幸福，美好……都是我看完的第一想法；独步天下，绝无仅有……则是第二想法。</p><p>连续两个中午未眠，再加上考完试的轻松，让我在$3$月$28$日中午读完了这本书。还有二十分钟才吹起床哨，遂决定小眠片刻，谁知梦里朦胧的，全是言叶里面的内容，全是雪野和孝雄，全是棉花糖一样柔软香甜的梦幻，在我的脑海里欺负、沉淀、卷缩、舒张——那真是我有生以来经历过的最单纯而又美好的时光之一。</p><p>我更加坚定地认为，这种只属于梦幻的东西，这种“天上语”，“天籁之音”，都应该留在那个梦幻的世界里——大抵上就是要把“现实”和“梦幻”割裂开来吧。我认为，把这种“此曲只应天上有，人间难得几回闻”的美好，带到这个现实的、令人失望的世界，是一种对它的侮辱。</p><p>所以，我不打算去看知乎的评论，不愿去看书评，不愿去与别人聊起这部小说——我只想把这种最单纯的梦幻，留给最纯粹的世界，精心地呵护。</p><p>……</p><p>说起原因，大抵上有很多。比如电影里剧情的淡薄，在这部小说里得到了很好的充实，让我满足得很；比如雪野和孝雄之间未曾言明，但是却无比真挚、无比纯粹、无比坚固的爱情——那是最美好的爱情了吧，厮守，陪伴大概是最长情的告白；比如书中每个人的心理活动，细腻，真切，读起来一气呵成；比如……</p><p>但是我总感觉，这些其中的某个，或者是他们的并集，从客观上讲，都不能成为让我如此动容的理由。</p><p>现在想来，上一次如此感动至深，还是在看真人电影版的《我想吃掉你的胰脏》的时候。我自认为像这种具有强大感染力的文艺作品，用动画去表现实在是太单薄了——或许需要好的演员，或许需要好的文字，总之，小说和真人电影，都要有更好的效果——当时哭的稀里哗啦的。我也不知道到底为何而哭，明明男女主之间都没有令人羡慕的爱情，明明女主最后都已经在劝男主忘掉她，明明情节就是那么的简单俗套……</p><p>我不知道为什么。</p><p>总之，很美就对了。我大概需要再过好多好多天才能缓过来吧。现在的状态大概是一闲下来就会想起言叶里面的内容，每当独自一个人时，脑子里便全是$1.$百香里和孝雄之间如潺潺不绝的流水一样的真挚感情$2.$百香里是如何一个人扛过那些岁月的$3.$他们最后相遇以后会怎样，在一起之后会怎样的快乐……感觉自己仿佛变成了一个多情细腻的小姑娘，重复回想着书中的一幕幕。“如果站在新海诚的作家立场上看，他这本书对我这个读者来说，已经是极为成功的了吧”我心想。</p><p>我甚至会幻想世界上真有一个百香里，一个孝雄，他们在某个时间点相遇、相伴、相携、相知、相爱……那该是多美好的童话啊。或许百香里经历的一切，其背后的原因都是那么的无厘头、甚至是荒谬——毕竟是青春期的孩子一首酿成的错误——但或许老天是为了有个利用奖赏给她一份完美的、童话般的爱情，才会先让她经历一些痛苦吧。毕竟如果雪野不经历这些，或许他跟孝雄就会是永远陌生人了……</p><p>突然感觉自己真的…居然都开始相信主观唯心主义了…真是不可救药地沉浸在这本书里了啊。</p><p>这绝对是我读过的最美的故事了。</p><h1 id="rm-Part3"><a href="#rm-Part3" class="headerlink" title="$\rm{Part3}$"></a>$\rm{Part3}$</h1><p>现在是$3.27$的中午，我躺在寂静的宿舍里，看着《言叶之庭》——大概，“三分之一是读完了吧?”我想。</p><p>“这本书大抵上是新海诚在拍《言叶之庭》之前写的吧，”我想，“所以或许会跟很无聊，毕竟情节是都知道的”。确实，看完加版、重温完电影版之后，如果是相同的内容，对我来说确实是有点枯燥。</p><p>但是当我现在看到主角为“秋月翔太”这一章时，似乎感到了什么奇怪的事情发生了——书中对男主哥哥的描写得如此详细，甚至绝大部分情节都是原作里面没有的。虽然前面几节里面也有或多或少的情节没在电影里出现，但是一整章的内容全部掐掉，也未免太狠心了吧。</p><p>我突然开始着迷起来，开始觉得新海诚是个小天才了——其情节设置的是如此的合理，让我越来越感到满足。原本困倦的我似乎来了精神，“一定要赶紧读完”，我心想。</p><p>……</p><p>读完之后，后记里面新海诚是这么描述的：</p><blockquote><p>我一直单恋着小说。<br>不只是小说，我觉得自己也一直单恋着漫画、电影、动画与现实中的风景。也就是说，这是一<br>种「我喜欢对方，对方却对我没什么兴趣」的状态。我也知道自己是四十几岁的成年人了，不该再<br>想这些没有意义的事，但我却怎么样也摆脱不了这种情绪。</p><p>……</p><p>写小说是很愉快的，我能够尽情写出动画表达不出来的情节，或是很难的内容。例如，写到<br>「她的脸上浮现迷途孩子般的微笑」，我就会（对身为动画导演的自己）示威：「怎样！」怎样？<br>这句话很难用影像表现吧！演员能恰如其分诠释出「迷途孩子般的表情」吗？动画师能画出每个人<br>一看就知道是「迷途孩子」的脸吗？不可能！不安的表情或许可以办到，但是「迷途孩子般的」这<br>种简洁明白的形容，很难利用影像呈现。又或是当我写到：「门外的喧闹声，宛如从耳机里外溢的<br>声音……」，我就会狞笑心想：「这个你（影像）也做不到吧？」观众无法从教室的环境音联想到<br>耳机声音外溢云云。<br>我透过写作切身感受到，小说的乐趣就在于文字的连结。我注意到自己利用写后记的方式来回<br>顾那段时光时，就会独自感到雀跃不已，总之就是非常地幸福。</p><p>……</p><p>写完一本书最大收获，反而是更加深了我对于小说和动画的单恋情怀。反正我本来就不期待两<br>情相悦。我有时会想到，孝雄对雪野的感情，是否也有相似的东西？若这么说来，本书里的角色多<br>多少少都在单恋。我重新体悟到自己想写的，就是人们的这种心情——孤单渴望某个人、某项事物<br>的心编织出这个世界。而本书想要描述的就是这点。<br>在「爱」以前，这是段「孤独希求」的故事。<br>这句话是电影版的宣传文案。想必现代也有不少人对于远在一千三百年前的万叶时代，将「恋<br>爱」这个字，写作「孤悲（孤寂悲伤）」深表同感。</p></blockquote><p>我想，这大概也是这部小说迷人的因素之一吧——原本就已经很完整的情节，加上妙笔的勾勒，瞬间活灵活现起来。</p><h1 id="rm-Part-4"><a href="#rm-Part-4" class="headerlink" title="$\rm{Part~4}$"></a>$\rm{Part~4}$</h1><p>选了几段放到这里，留作纪念。</p><p>首先是最后，孝雄和雪野重逢的情景：</p><blockquote><p>走过日本庭园的木桥，雨声又起了些微变化。树叶摇曳的声音，胜过雨滴敲打水面的声音。自<br>制的雕花皮鞋，缓缓踏在土壤上的脚步声，伴着绿绣眼清脆的鸣啭。越过日本黑松所见到的水面、<br>杜鹃花倒映在水面上的粉红色、千头赤松树皮的红色，以及枫叶的灿绿色。<br>孝雄的后背包里装着为那个人打造的鞋子。那是一双约五公分高的小巧尖头高跟鞋，鞋尖是浅<br>粉红色，鞋身是近乎白色的浅肤色，脚踵处是仿佛阳光照耀的柠檬黄色，缠绕在脚踝上的长脚踝带<br>上缝着枫叶的形状。<br>这双鞋是为了那个人打造，一定可以走得更长更远。<br>不知从何处传来老乌鸦强有力的鸣叫，远方的天空隐约响起了雷鸣声。<br>——隐约雷鸣。<br>孝雄脱口而出这句话。<br>一股预感充满全身。<br>已经可以看到浸湿枫叶后侧的凉亭，那里坐着一个人。<br>孝雄吸入雨水的气味，克制住自己的心情，继续走向凉亭，穿过层层树叶后，整座凉亭映入眼<br>帘。<br>那是一位穿着浅绿色裙子的女人。<br>孝雄停下脚步。<br>有着一头剪至齐肩柔软短发的女人，正把咖啡举到嘴边，她轻轻瞥了他一眼。<br>看着雪野从快要哭出来的紧绷表情，逐渐绽开笑容。<br>孝雄心想，雨好像停了。</p></blockquote><p>然后是孝雄表白完、雪野拒绝后，雪野的心声：</p><blockquote><p>「可是你的衣服还没干……」雪野望着他远去的背影，不由得大叫。<br>不对，这样正好。雪野逼自己收回视线，低头看着手中的咖啡杯，隐约听见他关上更衣间的<br>门。雪野把还没喝上一口的咖啡杯举到嘴边，袅袅升起的热气微微沾湿了睫毛。她想要喝咖啡，却<br>觉得杯子沉重异常，只得把它放回桌上。雪野体内有一团像刺猬般带刺的情绪，笨拙地四处乱闯。<br>这情绪似乎是后悔和内疚，正一阵阵刺痛雪野的心并沉默地责怪她。<br>不然我该怎么做？雪野几乎就要哭出来了。我从一开始就没有选择的余地。我明明那么真诚地<br>对待每一个人，明明想成为像阳菜子老师那样温柔体贴的大人，明明努力回应任何一个需要我的<br>人。雪野看着逐渐稀薄的咖啡热气。我不要待在世界的外围，我想进到世界的里面，我想成为这个<br>耀眼世界的一部分。我以为只要长大，一切就会顺利；我以为照这样下去，就能和大家一样正常生<br>活。可是，却发现自己被卷入那些像淋雨般避不掉的灾难里。先是伊藤老师出现，然后牧野同学出<br>现，最后相泽同学也出现，我的生活变得一团糟。好不容易来到屋檐下可以躲躲雨，这回秋月出现<br>了。每个人都在扰乱我的心，我想要静静地待着。但我一个人就连只是站着，都如此勉强，每天光<br>是不让自己蹲下，就必须耗费莫大的力气。<br>听见脚步声慢慢移近，雪野抬起头。他站在浅浅的青绿色影子里，身上已经换上应该还是半干<br>的制服。<br>「那个，我要走了。各方面来说，非常感谢你。」他静静说完，深深一鞠躬，不等雪野回应便<br>朝着玄关走去。<br>「啊！」<br>雪野不自觉离座起身。等等，多待一会儿吧。你没有带伞，对吧？等雨停再走吧？——不对，<br>不是这样，不可以这样说。雪野默然不语，又一次慢慢坐回椅子上。他的脚步声愈来愈远，穿鞋的<br>声音，转开门把的声音。然后——</p><p>啪嗒。关门的声音。<br>那一瞬间，雪野突然感到很气愤。<br>「笨蛋！」<br>她大吼一声，抓起坐着的椅子作势要扔出去，可是，她怒视的前方已经没有半个人在。她顿时<br>泄气地慢慢放下椅子，再次坐了下来。<br>「……笨蛋。」她小声地又说了一次。<br>秋月那个笨蛋。<br>一副单方面被甩的受害者表情、一副自己没做错任何事的表情，你根本不知道你没来凉亭的暑<br>假里，我是怀抱着什么样的心情度过。你的高一暑假一定过得很欢乐吧！你可以每天和家人一起吃<br>饭，可以和班上女同学去喝茶，你根本完全无法想像大你十二岁的女人过着什么样的生活。<br>一阵鼻酸，热气堵住喉咙，胸口苦闷难受，眼眶渗出泪水，她以手掌紧紧按住双眼阻止这一<br>切，湿眼皮内侧浮现犹如细窄迷宫般的白色纹路。始终搁在桌上的那杯咖啡，仍在无声无息地持续<br>冷却着。<br>——结束这段时光的人，是你啊！<br>雪野不禁有些埋怨。你果真还是个孩子。如果你不说那种话，我们说不定还能一起吃饭、交换<br>连络方式，或是你会在我要回老家那天来送我，说不定我们还能够以温和平静、痛苦最少的方式，<br>静静地结束我们的关系。<br>其实我一直在忍耐。<br>其实我一直没有说出口。<br>其实我一直没有说出来过——</p><p>我喜欢你。</p></blockquote><p>还有两段段很有名的摘录下来：</p><blockquote><p>二十七岁的我，丝毫不比十五岁时候的我聪明。<br>雪野望着阳光愈来愈炫目、影子逐渐加深的庭园，带着有人在为自己打分数的心情，如此想<br>着。</p></blockquote><p>还有孝雄的情感爆发：</p><blockquote><p>孝雄故意打断她的话，什么也不想听，「雪野姐，请你忘了我刚才说的话。」<br>仿佛事先背好的台词，孝雄很自然、干脆地说出这句话。他直直望着雪野，说出必须说的话，<br>说出他觉得为了她应该要这么说的话：「我其实很讨厌你。」<br>吹进来的雨滴打在脸颊上。雪野十分哀伤地眯着眼。孝雄真的觉得自己非常厌恶事到如今才<br>露出这副表情的她。<br>「我一开始就觉得你这个人……有够讨厌，一大早就在公园里喝啤酒，还留下莫名其妙的和<br>歌。」孝雄说着。<br>过去因为这个雨女而尝到的困惑、焦躁、嫉妒、憧憬、期盼、祈求、希望、绝望等所有情绪，逐渐化为怒意。他再也管不住自己的嘴巴。<br>「你从来不说自己的事，却老是探听我的事。你早就知道我是你的学生吧？你这种做法有够卑<br>鄙！」<br>讨厌！我讨厌这个女人。一副受到伤害的表情，现在又一副要哭的样子，我最讨厌她了！<br>「如果知道你是老师，我绝对不会告诉你鞋子的事。反正你会觉得那是做不到，也不可能实现<br>的梦想，对吧？你为什么不那样说？还是你觉得这只是小孩子讲的话，随便应付一下就好？」<br>讨厌！我讨厌自己像孩子一样，为这种事情嚷嚷。<br>「你一开始就知道我向往什么、憧憬谁，也知道那个人不会接受、目标永远不会实现。你都知<br>道！」<br>我讨厌自己在女人面前哭得这么难看，我一直一直努力当个大人，你却把我变成这副模样。我<br>讨厌你！<br>「……既然如此，你应该一开始就对我说啊！说我碍事！说臭小子快去上学！说你讨厌我！」<br>但如果不这么做，我会一辈子都爱着你。好喜欢好喜欢好喜欢，就连现在的每一分每一秒也更<br>加喜欢你。<br>「你就一直那样……」<br>——开什么玩笑，怎么连你也哭了？<br>「你就一直那样，摆出若无其事的表情……」<br>秋月的泪水滴滴答答滑落，大吼着。<br>「——一直孤单一人，度过一生吧！」</p></blockquote><p>……</p><p>今天是三月二十九日，我突然好像明白了自己如此着迷与这个故事的原因。</p><p>孤独。</p><p>对，就是这个词，孤独。</p><p>无论是《我想吃掉你的胰脏》真人电影也好，《言叶之庭》也好，男主一直是孤独的——只不过他们自己不觉得孤独，但是却有一种呼之欲出的孤独感；紧接着他们分别遇到了女主，从此开始不再孤独——孝雄可以每逢雨天去亭子里和雪野相见，春树也可以每天有樱良为伴——虽然不清楚春树到底喜不喜欢这样。</p><p>总之，本来单调的生活，突然就多彩了起来：眼前是未曾见过的亮丽景色。一切仿佛是命中注定，有种天赐的使命感让你爱她，而她也让你的生活看起来没有那么无聊——“每个不曾起舞的日子。都是对生命的辜负”，她或许就是你生命中的领舞者。总之，心中如同拨云见日了一样，有着明快的节奏和爽朗的旋律。</p><p>或许新海诚已经说出来了，他想营造的就是“孤独”的气氛，而这冰凉冰凉的孤独如同一把有着水蜜桃香气的箭，穿过我胸腔前薄薄的几层肌肤，直戳我内心最柔软的地方——我好孤独啊。</p><p>或许一旦我忙起来，我就不再对《言叶》有这么深厚的感情了；或许一旦我有了可以让我的生活热闹起来的人，我就不再对《言叶》有这么深层次的共鸣了；或许……</p><p>但我没有啊，哈。</p><p>但是我因此而悲伤吗？或许吧。但我更庆幸可以有这个机会，想未谙世事的小女孩一样肆意幻想这个世界上最美好的东西。这对我来说，或许已经足够了。</p><p>天边是一抹飘逸的鱼肚白，点缀着一只金黄色的太阳，随卷舒的云在碧蓝的天空中摇曳，有着别致的美感。</p><h1 id="rm-Part-5-Ending"><a href="#rm-Part-5-Ending" class="headerlink" title="$\rm{Part~5/Ending}$"></a>$\rm{Part~5/Ending}$</h1><p>今天是$3$月$31$日，我终于可以直面一些东西了。比如我在听到言叶的主题曲时，不在感到孤独和压抑，更多的则是对新生活的盼望。</p><p>我一直在想，这本书到底能带给我什么。</p><p>是如何小心地呵护一个人吗？是为了一个目标（比如孝雄对制鞋）要不断披荆斩棘吗？是要坚强吗？是要珍惜身边每一个人吗？是……？……</p><p>我不知道，但我觉得我列举的每个目的都太肤浅。</p><p>或许读书，读一个令人感动的故事，真的不会带来什么特别的东西。但那会化成血与肉，填充进我的身体；会化成一缕青烟，迷蒙在我的脑海里，最终沉积下来，到它应该到的地方去。</p><p>说的太模糊了，“到它应该到的地方去”，究竟是到哪去呢？是沉积到脑袋里，沉积在心里，还是沉积在我身体上随便哪个器官上？又或许它根本不会停留，于我而言只是一个过客，可以突然从我身上蒸发走呢……？</p><p>我不会知道——毕竟，我连自己的路都仍不知要如何去走，我连自己的去处都仍不知该何处寻觅，这种事情我也更不会知道了吧。</p><p>$\mathfrak{Orchidany, 3,31,2019}$</p>]]></content>
    
    <summary type="html">
    
      击中了我的心——孤独是耐人寻味的孤独。
    
    </summary>
    
      <category term="Life" scheme="https://Flower233pks.github.io/blog/categories/Life/"/>
    
    
      <category term="随想/下下笔" scheme="https://Flower233pks.github.io/blog/tags/%E9%9A%8F%E6%83%B3-%E4%B8%8B%E4%B8%8B%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>线性规划入门·对偶定理</title>
    <link href="https://Flower233pks.github.io/blog/2019/03/19/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/"/>
    <id>https://Flower233pks.github.io/blog/2019/03/19/线性规划对偶定理/</id>
    <published>2019-03-19T06:09:15.000Z</published>
    <updated>2019-07-24T13:38:27.416Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/blog/assets/css/APlayer.min.css"><script src="/blog/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><img src="https://img.shields.io/badge/%E9%9A%BE%E5%BA%A6-%E7%9C%81%E9%80%89---purple.svg" alt></p><h1 id="rm-Preface-About-Duality-Theorm"><a href="#rm-Preface-About-Duality-Theorm" class="headerlink" title="$\rm{Preface:} About~Duality~Theorm$"></a>$\rm{Preface:} About~Duality~Theorm$</h1><p><strong>线性规划对偶定理</strong>：我们朴素的线性规划大致如下：<br>$$<br>\text{最大化}\quad \sum c_ix_i \quad(i = 1, 2,3 \cdots n) \\<br>\text{满足约束} \quad \sum \limits_{j=1}^{n} a_{i,j}x_{j} \leq b_i\quad (i = 1,2,3\cdots m) \\ \qquad \qquad \qquad \quad x_j \geq 0\quad (j=1,2,3\cdots n)<br>$$<br>那么我们称它的<strong>对偶</strong>为形如下的线性规划：<br>$$<br>\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)<br>$$<br><a id="more"></a></p><p>换做矩阵表示就会是这样：<br>$$<br>\text{最小化}\quad \boldsymbol{b^Ty} \\<br>\text{满足约束} \quad A^T\boldsymbol{y\geq c} \\\<br>\it{\qquad \qquad \quad} \boldsymbol {y} \geq 0<br>$$<br>那其实比较显然的是，我们原来线性规划中的约束向量与目标函数里的系数向量交换，目标函数的最大化变成了最小化。现在我们思考对偶的意义。</p><p>首先假设我们有这么一个线性规划：<br>$$<br>\text{最小化}\quad \sum b_iy_i \quad(i = 1, 2,3 \cdots m) \\<br>\text{满足约束} \quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n) \\ \qquad \qquad \qquad \quad y_j \geq 0\quad (j=1,2,3\cdots m)<br>$$<br><del>其实就是上面那个</del></p><p>我们的目的其实等价于确定目标函数的下界。我们观察每一组约束，假设有一组约束是<br>$$<br>\quad \sum \limits_{j=1}^{m} a_{p,j}y_{j} \geq c_p\quad (i = 1,2,3\cdots n)<br>$$<br>并且我们保证有：<br>$$<br>\forall a_{p,j} \in \boldsymbol{a_p},\forall b_i \in{\boldsymbol{b}},\quad i=j \Longrightarrow b_i\geq a_{p,j}<br>$$<br>好像写的很不规矩……意思就是对应项的系数，目标函数都比这个约束里的大。</p><p>那么因为$\forall x\geq 0$，所以我们可以保证目标函数的最小值一定会是$c_p$。这个结论是显然的。</p><p>更进一步，那么我们最后确定的下界一定会是这样的（此处一点也不严谨地使用了$\Omega$符号）：<br>$$<br>\Omega(\rm{Aim}) = \it{\sum \limits_{j = 1}^{n}t_j\cdot\sum\limits_{i=1}^{n}\sum \limits_{k=1}^{m}a_{i,k}y_k}\\\<br>\forall t_j \geq 0<br>$$</p><p>而因为我们对于原来的约束有<br>$$<br>\quad \sum \limits_{j=1}^{m} a_{i,j}y_{j} \geq c_i\quad (i = 1,2,3\cdots n)<br>$$<br>所以我们将其代回我们画好的式子里面：<br>$$<br>\Omega(\rm{Aim}) \geq \it{\sum\limits_{j=1}^{n}t_jc_j}<br>$$<br>那么……目标函数的下界就变成了一个和式的上界——又变成了一个求解目标函数最大值的问题。</p><p>那么这或许感性证明了对偶定理的正确性？</p><h1 id="rm-Afterword-Some-Typical-Problem"><a href="#rm-Afterword-Some-Typical-Problem" class="headerlink" title="$\rm{Afterword:}Some~Typical~Problem$"></a>$\rm{Afterword:}Some~Typical~Problem$</h1><p><del>没见过吧，一篇文章只有前言和总结</del></p><p><del>其实博主就是在疯狂划水/摸鱼</del></p><p>其实常见的对偶问题有很多，博主功力不够，于是只能整理一个比较形式化的结论：</p><h2 id="最大流问题"><a href="#最大流问题" class="headerlink" title="$~$最大流问题"></a>$~$最大流问题</h2><p>形式化的最大流问题的线性规划如下：<br>$$<br>\text{最大化}\quad \quad \quad ~f_{s\to t} \quad ~ \quad \quad \quad \quad \quad \quad \\<br>\text{满足约束} \quad \quad f_{u\to v} \leq L_{u \to v}\qquad (u,v) \in E \\ <br>\qquad \quad \quad ~\sum\limits_{u}f_{u \to v} = \sum\limits_{v}f_{v \to u}\qquad u\in V<br> \\ \qquad \qquad \qquad ~~\quad f_{u\to v} \geq 0 \qquad (u,v) \in E ~\cup \text{e(s,t)}<br>$$<br>其中$e(u,v)$表示链接$u,v$的路径集合，$f$表示流量，$L$表示容量(Limit)。</p><p>其对偶过去就会是：<br>$$<br>\text{最小化}\quad \quad \quad \sum_{(u,v)\in E}L_{u\to v}d_{u \to v} \quad ~ \quad \quad \quad\\<br>\text{满足约束} \quad \quad d_{u\to v}-p_u+p_v \geq 0\qquad (u,v) \in E \\ <br>\qquad \quad \quad \quad \quad \quad ~~p_s - p_t \geq 1\qquad u\in V<br> \\ \qquad \qquad \qquad \quad  p_i,d_{i\to j}\in\{0,1\} ~\qquad<br>$$<br>里面$d_{i\to j}$表示$i \to j$这条边有没有被割，同时假设我们割完之后，原来的图分成了两部分$S$和$T$,那么会有$p_i = [i \in S]$。这个限制是为了保证割的逻辑性——所有的割边都连接着$S,T$两个集合，且源点和汇点在不同的集合。</p><p>emmm我实在不想再整理了(写式子太麻烦)，等什么时候我退完役闲下来再说吧233</p><h2 id="rm-Reference"><a href="#rm-Reference" class="headerlink" title="$\rm{Reference}$"></a>$\rm{Reference}$</h2><ul><li>$[1]$ :2016国家集训队论文《浅谈线性规划与对偶问题》董克凡· <a href="https://pan.baidu.com/s/1aN2L7DAm_RY2GeN5Snxj1A" target="_blank" rel="noopener">$^{^{[\nearrow]}}$</a> 提取码：vua4</li></ul>]]></content>
    
    <summary type="html">
    
      通常的线性规划用于求解一类满足正向约束的最大值问题，但是通过对偶可以将其转化成一类求解满足逆向约束的最小值问题。
    
    </summary>
    
      <category term="学习笔记" scheme="https://Flower233pks.github.io/blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
      <category term="线性规划" scheme="https://Flower233pks.github.io/blog/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92/"/>
    
    
      <category term="线性规划/单纯形法" scheme="https://Flower233pks.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%8D%95%E7%BA%AF%E5%BD%A2%E6%B3%95/"/>
    
      <category term="线性规划/对偶定理" scheme="https://Flower233pks.github.io/blog/tags/%E7%BA%BF%E6%80%A7%E8%A7%84%E5%88%92-%E5%AF%B9%E5%81%B6%E5%AE%9A%E7%90%86/"/>
    
  </entry>
  
</feed>
